# Accumulated Learnings: Epics 01-04 (Gap Resolution)

## Key Patterns (Accumulated)

- **Subsection lettering** (`N.Ma`): All new subsections inserted between existing numbered sections use the `N.Ma` lettering convention (e.g., `SS5.4a`, `SS4.2a`, `SS2.1b`, `SS4.3b`, `SS3.1a`). This avoids renumbering and is established across the full spec corpus. Applies to every spec file. (Established: epic-03; reinforced: epic-04 with 12 new subsections across 9 files.)
- **Worked-example as verification baseline**: Concrete small examples (3-hydro AR(2), production-scale byte counts, LP solve timing estimates) are explicitly framed as "verification baselines" in the spec. Used in `src/specs/architecture/solver-abstraction.md` SS2.4, `training-loop.md` SS5.4a, `convergence-monitoring.md` SS2.3a. Prevents abstract specs from hiding index arithmetic errors.
- **One canonical source, cross-references only**: Index formulas, enum definitions, and wire format layouts are defined in exactly one place; all other specs cross-reference by section link. Never duplicate math or struct definitions. Established in `src/specs/architecture/solver-abstraction.md` SS2.1; reinforced in epic-04 (TrainingEvent in `training-loop.md` SS2.1b, CutWireRecord in `cut-management-impl.md` SS4.2a, seed derivation in `scenario-generation.md` SS2.2a).
- **Stakeholder Decision blockquote**: Open-point and open-question markers are replaced with a `> **Stakeholder Decision**: ...` blockquote that includes rationale and deferred-work notation. Used in `src/specs/architecture/solver-abstraction.md` SS3 (SolverAuto scaling) and SS5.4 (selective cut loading). The alternative is preserved as a deferred optimization, not deleted.
- **Resolution Log in gap inventory**: `src/specs/overview/spec-gap-inventory.md` Section 7 is the single structured tracking table. Every gap resolution adds one row: gap ID, date, plan/epic reference, ticket ID, one-line summary. No gap is marked resolved without this row.
- **mdbook build as the sole E2E gate**: `mdbook build` from repo root is the only testing requirement for documentation tickets. All 15 epic-04 tickets passed without broken links.

## Architectural Decisions (Accumulated)

- **Raw `[f64]` for hot-path MPI collectives; rkyv for initial broadcast only**: State vector `allgatherv` (`training-loop.md` SS5.4a) and cut sync `allgatherv` (`cut-management-impl.md` SS4.2a) use raw byte reinterpretation. rkyv is restricted to the single `System` broadcast at startup. Native endianness is assumed for MPI jobs (homogeneous architecture).
- **`#[repr(C)]` with explicit padding for `CutWireRecord`**: The cut wire format uses a 4-byte padding field after `forward_pass_index` (u32) to align `intercept` (f64) to 8 bytes. Struct is in `cut-management-impl.md` SS4.2a; size is `24 + n_state * 8` bytes (16,664 bytes at production scale). The `allgatherv` uses `T = u8` because the variable-length coefficient tail makes the record variable-size.
- **SolverAuto (delegate scaling to backend) as baseline**: Cobre does not apply its own scaling in the minimal viable solver. HiGHS and CLP internal scaling is active. Cobre-managed scaling (GeometricMean, Equilibration) is deferred. Decision in `src/specs/architecture/solver-abstraction.md` SS3.
- **Selective cut addition as baseline**: Only active cuts are added via `addRows` at each stage transition. Bulk loading with inactive cuts deactivated via bound toggling is deferred. Decision in `src/specs/architecture/solver-abstraction.md` SS5.4. Rationale: smaller LP, natural fit for full-rebuild strategy, presolve remains disabled for warm-start compatibility.
- **SipHash-1-3 via `siphasher` crate for seed derivation**: `std::collections::hash_map::DefaultHasher` is explicitly excluded because its output is not stable across Rust versions. Input encoding is little-endian fixed-width integers (20 bytes for training, 16 bytes for opening tree). Specified in `src/specs/architecture/scenario-generation.md` SS2.2a.
- **`ReduceOp::Min` for lower bound allreduce as numerical guard**: All ranks independently compute the same LB (stage-1 LP objective), making the allreduce mathematically redundant. `Min` is kept as a defensive guard against floating-point non-determinism across NUMA nodes. Two separate allreduce calls: one `Min` for LB, one `Sum` for UB statistics `[cost_sum, cost_sum_sq, count]`. Specified in `src/specs/architecture/training-loop.md` SS4.3b.
- **Bessel's correction ($N-1$) for upper bound variance**: The prior `(sum_sq/N) - mean^2` (population variance) was incorrect for the 95% CI. Updated in `src/specs/architecture/convergence-monitoring.md` SS3.1 and SS3.1a. Single-pass formula accepted for typical SDDP cost distributions; catastrophic cancellation risk documented with a concrete relative-error bound.
- **ferrompi uses `Mpi` RAII guard, not `init_with_threading`**: The real ferrompi crate (github.com/rjmalves/ferrompi) exposes `Mpi::init_thread(ThreadLevel)` and `Mpi::world()`, not a free function `init_with_threading`. The speculative API assumed in the original ticket was replaced entirely. Full rewrite affected `src/specs/hpc/backend-ferrompi.md` SS7 (913 lines changed), plus stale references in `hybrid-parallelism.md` and `slurm-deployment.md`.
- **`load_case` returns owned `System`, not `Arc<System>`**: The cobre-io / cobre-core boundary function returns `pub fn load_case(path: &Path) -> Result<System, LoadError>`. Ownership transfer is simpler and broadcasting creates a copy anyway. Policy loading is excluded. Defined in `src/specs/architecture/input-loading-pipeline.md` SS8.1.
- **Simulation stopping rule is synchronous and reuses training workspaces**: No separate LP instances for simulation checks. The check blocks the training loop at every `period`-th iteration. Scenario source is fresh InSample draws with a separate seed. First check stores baseline but does not trigger convergence. Specified in `src/specs/architecture/convergence-monitoring.md` SS2.3a.
- **`TrainingEvent` enum lives in cobre-core, not cobre-sddp**: cobre-cli, cobre-tui, cobre-mcp all depend on cobre-core but not cobre-sddp. Events derive `Clone + Debug` only; `Send + Sync` is not needed because the channel transfers ownership. Events do not carry timestamps — consumer timestamps on receipt. Defined in `src/specs/architecture/training-loop.md` SS2.1b.
- **Fixed-size rayon thread pool, `rayon::current_thread_index()` as workspace key**: Each thread always accesses the workspace at its own thread index regardless of which task it executes. Workspaces are not freed between training and simulation phases (preserves warm-start basis caches). Destruction calls `Highs_destroy()` / `Clp_deleteModel()` sequentially on the main thread. Specified in `src/specs/architecture/solver-workspaces.md` SS1.3a.

## Files and Structures Created (Accumulated)

- `src/specs/overview/ecosystem-guidelines.md` — Durable development conventions for the Cobre ecosystem (epic-01)
- `src/specs/data-model/internal-structures.md` SS1 — `System` struct with entity collections, topology, bounds, lookup indices (epic-02)
- `src/specs/architecture/solver-abstraction.md` SS2.1/SS2.2/SS2.4/SS2.5 — LP memory layout, lag row assignment, StageIndexer verification baseline, performance notes (epic-03)
- `src/specs/architecture/training-loop.md` SS4.2a — Forward pass patch sequence with exact `patch_row_bounds` calls (epic-03, renamed epic-04)
- `src/specs/architecture/training-loop.md` SS2.1b — `TrainingEvent` enum (11 variants) with typed payload structs (epic-04)
- `src/specs/architecture/training-loop.md` SS4.3b — Lower bound extraction with two-allreduce protocol and `ReduceOp::Min` rationale (epic-04)
- `src/specs/architecture/training-loop.md` SS5.4a — State vector MPI wire format: `counts[r] = M_r * n_state`, per-stage granularity, 3.19 MB sizing note (epic-04)
- `src/specs/architecture/cut-management-impl.md` SS4.2a — `CutWireRecord` `#[repr(C)]` struct with padding, `24 + n_state * 8` byte formula (epic-04)
- `src/specs/math/lp-formulation.md` SS5a — AR Lag Fixing Constraints as a formal constraint family with dual variable $\pi^{lag}_{h,\ell}$ (epic-04)
- `src/specs/architecture/scenario-generation.md` SS2.2a — SipHash-1-3 seed derivation with little-endian 20-byte and 16-byte input encodings (epic-04)
- `src/specs/architecture/convergence-monitoring.md` SS2.3a — Simulation-based stopping rule integration: synchronous, workspace reuse, first-check baseline behavior (epic-04)
- `src/specs/architecture/convergence-monitoring.md` SS3.1a — Upper bound variance aggregation: Bessel's correction, numerical stability note, $N=1$ edge case (epic-04)
- `src/specs/architecture/input-loading-pipeline.md` SS8.1 — `load_case` public API signature with `LoadError` enum (5 variants) (epic-04)
- `src/specs/architecture/cli-and-lifecycle.md` SS5.2a — Phase-Training Loop alignment table mapping 7 phases to specific spec sections (epic-04)
- `src/specs/architecture/solver-workspaces.md` SS1.3a — Workspace lifecycle summary: creation, per-iteration reuse, per-stage transition, destruction phases (epic-04)
- `src/specs/hpc/backend-ferrompi.md` SS7 — ferrompi API Reference: `Mpi` RAII guard, `Communicator`, `SharedWindow<T>`, supporting types — full rewrite against real crate API (epic-04)

## Conventions Adopted (Accumulated)

- **Section-reference cross-links over narrative descriptions**: Any reference to another spec section uses the mdBook relative link format `[Description](./file.md#section)`. Inline references to section numbers (e.g., "see SS2.1") are supplemented with actual links wherever a developer might navigate there.
- **`patch_row_bounds` / `patch_col_bounds` (not `patch_rhs_bounds`)**: The split API is now canonical throughout the spec corpus. All 5 affected files (`solver-interface-trait.md`, `training-loop.md`, `solver-workspaces.md`, `solver-abstraction.md`, `spec-gap-inventory.md`) have been updated. Any implementation or future spec that references LP patching must use the two-method API.
- **Performance notes with concrete numbers**: Specs that describe hot-path operations include numeric performance analysis: byte counts, LP solve time estimates, allreduce payload sizes, SIMD alignment requirements. Vague "consider performance" guidance is not acceptable. See `training-loop.md` SS5.4a (3.19 MB sizing), `convergence-monitoring.md` SS2.3a (840 solves, ~1.7s), `solver-abstraction.md` SS2.5 (cache occupancy), `cut-management-impl.md` SS4.2a (16,664 bytes/cut).
- **Deferred-work notation**: Work excluded from the minimal viable solver is marked "deferred to a later optimization pass" consistently. This applies to two-phase LP scaling, bulk cut loading, two-pass variance, and custom MPI reductions.
- **Spec-agnostic `#[repr(C)]` structs**: Wire format structs include explicit field-by-field padding rationale. The `CutWireRecord` comment on `_padding: u32` explains alignment of the following `f64`. This pattern prevents silent ABI bugs.

## Surprises and Deviations

- **ticket-022 complete rewrite (ferrompi real API)**: The original ticket assumed a speculative API (`init_with_threading`, `Universe`, `CommData` trait, free functions). Inspection of the real ferrompi crate (github.com/rjmalves/ferrompi) revealed the actual API uses an `Mpi` RAII guard, `Mpi::init_thread(ThreadLevel)`, `Mpi::world()`, `MpiDatatype` trait (not `CommData`), `split_shared()` (not `split_shared_memory()`), `local_slice`/`remote_slice`/`local_slice_mut` (not `as_slice`/`as_mut_slice`), and `SharedWindow::allocate` (not `SharedWindow::new`). The resulting SS7 section is 913 lines of additions and covers the full public API including persistent collectives (`allreduce_init`) and SLURM helpers (`ferrompi::slurm`). Additionally, `hybrid-parallelism.md` and `slurm-deployment.md` had stale references to the old speculative names that were corrected. Quality score 0.94 (test_delta: 0.5 — the section is significantly larger than anticipated, with more public API items than the original 15-item minimum).
- **ticket-015 and ticket-019 test_delta = 0.0**: Both are pure documentation tickets that add subsections to existing Markdown files. The quality scorer assigns 0.0 for `test_delta` because no test files were added or modified. This is mechanically correct per the rubric but is an expected artifact of the documentation-only nature of all epic-04 work. The composite scores (0.90) remain ACCEPTABLE. Future epics should consider adding a documentation-only exemption to the rubric.
- **ticket-020 lower atomicity score (0.6)**: The simulation stopping rule ticket had a low atomicity readiness score because it touched convergence monitoring, stopping rules, scenario generation, and solver workspaces all in one ticket. In retrospect, the integration spec (SS2.3a) could have been split from the performance note (separate ticket), but the guardian accepted the scope and quality was 0.89 ACCEPTABLE. No action required.
- **AR lag fixing already partially present in lp-formulation.md**: The ticket-013 audit found that the lag fixing constraint was already expressed as a "State expansion" remark in SS5. The ticket promoted it to a formal section (SS5a) rather than creating it from scratch. The dual variable symbol $\pi^{lag}_{h,\ell}$ was already consistent across SS5 and Training Loop SS7.2 — no symbol changes were needed.
- **Lower bound allreduce is mathematically redundant but kept**: The discovery that all ranks independently compute the same LB value (same initial state, same cuts, identical stage-1 LP) means the `allreduce Min` for LB is a no-op in exact arithmetic. The spec documents this explicitly and keeps the allreduce as a defensive guard against NUMA-induced floating-point non-determinism. This is a real-world HPC correctness concern, not over-engineering.

## Recommendations for Epic 05

- Epic 05 addresses Medium-severity gaps. With all High-severity gaps resolved, the spec corpus is now self-consistent at the architecture level. Medium gaps are expected to be more localized (individual subsection additions) rather than cross-cutting (multiple files updated per ticket).
- ticket-022 demonstrated that any ticket specifying a third-party crate API must verify the API against the actual source repository before writing the spec. Add a "Verify against real API" step to the implementation guide for any ticket involving external crates.
- The `patch_row_bounds` / `patch_col_bounds` rename is now complete. Any future ticket that adds new methods to `SolverInterface` should follow the row/col split convention and the `(index, lower, upper)` tuple pattern established in `src/specs/architecture/solver-interface-trait.md` SS2.3.
- The `TrainingEvent` enum (SS2.1b) and `LoadError` enum (SS8.1) are now the canonical event and error types. Medium-gap tickets that touch convergence monitoring, CLI, or loading should reference these types by section rather than re-defining them.
- `sddp-specialist` remains the correct agent for LP formulation, cut management, and convergence math. `data-model-format-specialist` is appropriate for wire format and serialization tickets. All 15 tickets passed guardian on first attempt — agent selection has been consistently correct.
