# Report 009: Triage of Medium and Low Gaps for Phase 1 Impact

**Date**: 2026-02-26
**Scope**: 18 unresolved gaps (13 Medium + 5 Low) from [Spec Gap Inventory](../../../src/specs/overview/spec-gap-inventory.md)
**Method**: Each gap is classified against the implementation phases defined in [Implementation Ordering](../../../src/specs/overview/implementation-ordering.md) section 5, using the classification criteria from ticket-009.

## 1. Classification Criteria

| Classification            | Definition                                                                                                                                                     |
| ------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Resolve-Before-Coding** | The gap means an implementer cannot write a function signature, type definition, or crate boundary API. Must be resolved in spec before implementation begins. |
| **Resolve-During-Phase**  | The gap means an implementer must make a choice, but the choice is local and reversible. Can be resolved as the relevant phase proceeds.                       |
| **Resolve-After-MVP**     | The gap affects a feature not in the minimal viable solver, or is a refinement that can be deferred without blocking any phase.                                |

## 2. Per-Gap Triage Table

### 2.1 Medium Gaps (13)

| Gap ID  | Description                                                            | Phase                            | Critical Path                                                                                                               | Classification            | Effort                  | Rationale                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| ------- | ---------------------------------------------------------------------- | -------------------------------- | --------------------------------------------------------------------------------------------------------------------------- | ------------------------- | ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| GAP-018 | Threading model for forward pass (rayon vs std::thread)                | Phase 6 (cobre-sddp training)    | Yes -- forward pass parallelization is the first non-trivial concurrent code in cobre-sddp                                  | **Resolve-During-Phase**  | Small (1 day)           | The choice between `rayon` and `std::thread::scope` is local to cobre-sddp and does not affect any crate boundary API or type definition. The spec already documents `rayon` as the recommended option (Training Loop SS4.3 mentions "rayon thread pool size" in the solver workspace lifecycle). The decision is reversible: both options produce the same `fn train<C: Communicator + SharedMemoryProvider>(...)` signature. An implementer can start with `rayon` (the spec-recommended default), benchmark, and switch if needed. No upstream or downstream crate is affected by this choice.                                                                                                                                           |
| GAP-019 | Solver retry configuration parameters missing from config reference    | Phase 6 (cobre-sddp training)    | No -- retry logic is internal to cobre-solver, with hardcoded defaults documented in Solver Abstraction SS7.1               | **Resolve-During-Phase**  | Trivial (hours)         | The resolution path offers two options: (a) add config parameters, or (b) document as internal constants. Either way, the implementer can hardcode the existing defaults (5 attempts, time budget) and expose configuration later. The retry contract is fully specified in Solver Abstraction SS7.1; only the user-facing knobs are missing. This does not block writing any function signature or type.                                                                                                                                                                                                                                                                                                                                   |
| GAP-020 | Output writer API for cobre-sddp to cobre-io handoff                   | Phase 7 (simulation + output)    | **Yes** -- this is the crate boundary API between cobre-sddp (simulation pipeline) and cobre-io (Parquet output)            | **Resolve-Before-Coding** | Medium (2-3 days)       | The simulation pipeline in Simulation Architecture SS6 describes streaming output but does not define the writer type or method signatures. An implementer of Phase 7 cannot write the cobre-sddp simulation loop without knowing the writer API: what methods to call, what types to pass, what thread-safety guarantees the writer provides. The Simulation Architecture spec says results are "streamed to the output writer" but the writer is undefined. This is a crate boundary gap that affects type definitions in both cobre-sddp and cobre-io.                                                                                                                                                                                   |
| GAP-021 | FlatBuffers schema for cut persistence not provided in full            | Phase 7 (simulation + output)    | No -- cut persistence is needed for checkpoint/resume, but the schema IS actually provided in Binary Formats SS3.1          | **Resolve-After-MVP**     | None (already resolved) | Upon inspection, the FlatBuffers schema IS present in full in [Binary Formats](../../../src/specs/data-model/binary-formats.md) SS3.1. The schema defines `BendersCut`, `StageCuts`, `VisitedState`, `StageStates`, `Vertex`, `StageVertices`, `StageBasis`, and `PolicyMetadata` tables with all field types and defaults. The gap description says "referenced but not provided in full" and "describes the schema conceptually" -- this was accurate at the time the gap was filed but the spec has since been updated. The `.fbs` file content for `flatc` code generation can be extracted directly from the spec code block. No further resolution needed.                                                                            |
| GAP-022 | `PrecomputedPar` concrete Rust type unspecified                        | Phase 5 (cobre-stochastic)       | Yes -- this is the primary output type of the PAR preprocessing pipeline                                                    | **Resolve-During-Phase**  | Small (1 day)           | The spec in Scenario Generation SS1.3 defines the complete memory layout: four arrays (`base`, `coefficients`, `scales`, `orders`) with exact dimensions, row-major ordering, and the runtime evaluation formula. What is missing is only the Rust struct name and constructor signature. An implementer can derive the struct directly from the array table: `struct PrecomputedPar { base: Vec<f64>, coefficients: Vec<f64>, scales: Vec<f64>, orders: Vec<u32> }` with the dimensional metadata. This is a local design decision within cobre-stochastic that does not affect any crate boundary -- the struct is consumed only within cobre-stochastic's own evaluation methods.                                                        |
| GAP-023 | Opening tree Rust type and ownership model unspecified                 | Phase 5 (cobre-stochastic)       | Partially -- the opening tree is produced by cobre-stochastic and consumed by cobre-sddp, making it a crate boundary type   | **Resolve-Before-Coding** | Small (1-2 days)        | The opening tree crosses a crate boundary: cobre-stochastic generates it, and cobre-sddp's backward pass consumes it. The spec defines the shape (T x N_openings x N_entities), the memory layout (opening-major), and the access pattern (sequential stage iteration within each opening). However, the Rust type is unspecified: is it a newtype over `Vec<f64>` with an accessor, or a trait, or a reference to a `SharedRegion<T>`? The ownership model matters because the opening tree is shared via `SharedMemoryProvider` for MPI (Hybrid Parallelism SS2). An implementer of cobre-stochastic cannot define the public API without knowing whether to return `OpeningTree`, `Arc<OpeningTree>`, or populate a `SharedRegion<f64>`. |
| GAP-024 | Cut activity tolerance default value missing from config               | Phase 6 (cobre-sddp training)    | No -- the tolerance is used in Level-1 cut selection, which has a clear algorithmic description                             | **Resolve-During-Phase**  | Trivial (hours)         | Cut activity detection checks whether a cut's dual multiplier exceeds a tolerance. The resolution is to set a default (1e-6) in the configuration reference. The implementer can hardcode this default and expose it as a config parameter. The algorithmic contract is clear: dual > tolerance means active. This does not affect any type definition or function signature.                                                                                                                                                                                                                                                                                                                                                               |
| GAP-025 | Penalty priority ordering validation rule missing                      | Phase 2 (cobre-io input loading) | No -- the penalty system works correctly without validation; this is a user-experience improvement                          | **Resolve-After-MVP**     | Trivial (hours)         | The penalty priority ordering is a recommendation, not a correctness requirement. The gap description itself states: "violations may cause suboptimal policy behavior but do not break algorithmic correctness." The LP formulation works regardless of penalty ordering. Adding a warning is a quality-of-life improvement that can be added after the minimal viable solver is functional. No function signature or type depends on this validation.                                                                                                                                                                                                                                                                                      |
| GAP-026 | Backward pass trial state distribution strategy unspecified            | Phase 6 (cobre-sddp training)    | Yes -- the backward pass is core to SDDP training                                                                           | **Resolve-During-Phase**  | Trivial (hours)         | Upon inspection, the Work Distribution spec SS2 already specifies: "The trial points are then distributed across ranks for the backward pass using the same static contiguous block assignment as the forward pass." The gap was filed before this clarification was added. The remaining ambiguity (if any) is minor: the block assignment formula is reusable from the forward pass. An implementer can apply the same `contiguous_block_assignment` function.                                                                                                                                                                                                                                                                            |
| GAP-027 | `training.forward_passes` config parameter has no default              | Phase 8 (cobre-cli)              | No -- the parameter exists in the config schema (Configuration Reference SS3), and the loader can reject configs without it | **Resolve-During-Phase**  | Trivial (hours)         | The configuration reference lists `training.forward_passes` with type `int` and no default ("---"). The resolution is a design decision: make it required (reject if missing) or set a default. Either choice is local to the config parsing code in cobre-io/cobre-cli and does not affect any crate boundary type. The implementer can start with "required, no default" (the simpler option) and add a default later if user feedback demands it.                                                                                                                                                                                                                                                                                        |
| GAP-028 | Policy compatibility validation for simulation warm-start              | Phase 7 (simulation + output)    | Partially -- simulation cannot proceed without policy validation, but the check list is already documented                  | **Resolve-During-Phase**  | Small (1 day)           | Simulation Architecture SS2 provides an 8-row validation table with specific properties to check (block mode, hydro count, AR orders, cascade topology, etc.). The gap notes that the "full specification is deferred to Deferred Features SSC.9" but for the minimal viable solver (no warm-start from external policies, only from own training output), the inline table is sufficient. The metadata format (PolicyMetadata in FlatBuffers SS3.1) already records `state_dimension`, `num_stages`, and other structural parameters. An implementer can implement the 8 checks in the table and defer the full validation algorithm.                                                                                                      |
| GAP-029 | Cross-reference validation checklist is "illustrative, not exhaustive" | Phase 2 (cobre-io input loading) | Partially -- the validation pipeline is the primary deliverable of Phase 2                                                  | **Resolve-Before-Coding** | Medium (2-3 days)       | The Input Loading Pipeline SS2.6 lists cross-reference checks but explicitly notes the list is "illustrative, not exhaustive." An implementer of the validation pipeline needs a complete, enumerated checklist to know when the work is done. Without it, the implementer must reverse-engineer all entity cross-references from the data model specs and guess which ones need validation. This is the kind of gap where "local and reversible" does not apply: a missed cross-reference check discovered post-MVP could require retroactive data model changes if the omission allowed invalid data through.                                                                                                                             |
| GAP-030 | Forward pass `TrajectoryRecord` data structure unspecified             | Phase 6 (cobre-sddp training)    | Yes -- trajectory records are produced in the forward pass and consumed in the backward pass within the same crate          | **Resolve-During-Phase**  | Small (1 day)           | The data that must be stored is fully specified: per-stage state vectors and costs for one forward scenario. The spec says "store the stage cost and the end-of-stage state." The layout choice (flat buffer indexed by `[scenario][stage]` vs. struct-of-arrays) is a performance optimization internal to cobre-sddp. The state vector format is defined in Training Loop SS5 (resolved GAP-005). An implementer has all the information needed to design the struct; the choice is local and does not cross any crate boundary.                                                                                                                                                                                                          |

### 2.2 Low Gaps (5)

| Gap ID  | Description                                                                                                        | Phase                         | Critical Path                                                                                                                                            | Classification           | Effort          | Rationale                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| ------- | ------------------------------------------------------------------------------------------------------------------ | ----------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------ | --------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| GAP-031 | `Stage` struct has ambiguous fields (`num_scenarios`, `sampling_method`) overlapping with `scenario_source` config | Phase 1 (cobre-core)          | No -- the `Stage` struct fields are populated from `stages.json` and the overlap is a naming/documentation issue, not a type conflict                    | **Resolve-During-Phase** | Trivial (hours) | The implementer of cobre-core will need to define the `Stage` struct and will naturally resolve the naming conflict when mapping `stages.json` fields to struct fields. The resolution path is clear: `num_scenarios` maps to `n_openings` from `stages.json`, and `sampling_method` is deprecated in favor of the top-level `scenario_source.sampling_scheme`. This is a documentation cleanup that the implementer can resolve inline.                                                                                                                                                                        |
| GAP-032 | Event channel type (`broadcast::Sender`) implies async runtime dependency                                          | Phase 6 (cobre-sddp training) | No -- the event channel is a monitoring convenience, not algorithmic core                                                                                | **Resolve-During-Phase** | Small (1 day)   | The Training Loop SS2.1b explicitly acknowledges this gap: "GAP-032 remains open for the channel mechanism design." The resolution path recommends `crossbeam::channel` or `std::sync::mpsc` for the synchronous CLI binary. The channel type is internal to cobre-core (where `TrainingEvent` is defined) and the training loop consumer. The implementer can start with `std::sync::mpsc` (zero external dependencies) and upgrade to `crossbeam` if backpressure or multi-consumer is needed. No crate boundary API depends on the channel implementation -- consumers receive owned `TrainingEvent` values. |
| GAP-033 | `SharedMemoryProvider` bound inconsistency between `train` and solver trait                                        | Phase 6 (cobre-sddp training) | No -- both `Communicator` and `SharedMemoryProvider` are implemented by all four backends (Communicator Trait SS4.5), so the bound is always satisfiable | **Resolve-During-Phase** | Trivial (hours) | The Communicator Trait SS4.5 explicitly states: "All four backend types implement both traits, so the `C: Communicator + SharedMemoryProvider` bound is always satisfiable." The gap is about documentation consistency (some signatures show `C: Communicator` without `+ SharedMemoryProvider`), not about a missing type or unsatisfiable bound. The implementer will use `C: Communicator + SharedMemoryProvider` on the `train` function and `C: Communicator` on solver-only functions. This is a local, obvious fix.                                                                                     |
| GAP-034 | Cut pool capacity formula assumes immutable `forward_passes`                                                       | Phase 6 (cobre-sddp training) | No -- the capacity formula is a pre-allocation strategy, and over-allocation is safe                                                                     | **Resolve-During-Phase** | Trivial (hours) | The formula `warm_start_cuts + max_iterations * forward_passes` is a worst-case pre-allocation. If `forward_passes` is immutable (which is the current spec assumption), the formula is exact. The resolution path says: "Confirm that `forward_passes` is immutable after initialization." The Configuration Reference SS3 shows `forward_passes` as a simple integer with no dynamic adjustment mechanism. The implementer can assert immutability as a precondition and document it. If dynamic adjustment is ever added (post-MVP), the pool can be re-allocated.                                           |
| GAP-035 | Example `config.json` uses `"method": "domination"` instead of `"method": "level1"`                                | Phase 8 (cobre-cli)           | No -- the example is documentation, not executable code                                                                                                  | **Resolve-After-MVP**    | Trivial (hours) | The example `config.json` in Configuration Reference SS7 shows `"method": "domination"` for cut selection, which is a deferred feature. The minimal viable solver uses Level-1. This is a documentation inaccuracy that does not affect any type definition, function signature, or crate boundary. The implementer of cobre-cli will write config parsing code based on the schema tables (SS3-SS6), not the example. Fixing the example is trivial but does not block any coding.                                                                                                                             |

## 3. Summary Statistics

### 3.1 By Classification

| Classification        | Medium | Low   | Total  |
| --------------------- | ------ | ----- | ------ |
| Resolve-Before-Coding | 3      | 0     | **3**  |
| Resolve-During-Phase  | 8      | 4     | **12** |
| Resolve-After-MVP     | 2      | 1     | **3**  |
| **Total**             | **13** | **5** | **18** |

### 3.2 By Phase

| Phase                         | Resolve-Before-Coding | Resolve-During-Phase | Resolve-After-MVP | Total  |
| ----------------------------- | --------------------- | -------------------- | ----------------- | ------ |
| Phase 1 (cobre-core)          | 0                     | 1                    | 0                 | 1      |
| Phase 2 (cobre-io)            | 1                     | 0                    | 1                 | 2      |
| Phase 5 (cobre-stochastic)    | 1                     | 1                    | 0                 | 2      |
| Phase 6 (cobre-sddp training) | 0                     | 8                    | 0                 | 8      |
| Phase 7 (simulation + output) | 1                     | 1                    | 1                 | 3      |
| Phase 8 (cobre-cli)           | 0                     | 1                    | 1                 | 2      |
| **Total**                     | **3**                 | **12**               | **3**             | **18** |

### 3.3 Verification

Classification totals: 3 + 12 + 3 = 18. Matches the 18-gap input count (13 Medium + 5 Low).

## 4. Known Performance Risks Assessment

The spec gap inventory section 5 identifies 5 known performance risks. Each is assessed for impact on the minimal viable solver.

### 4.1 Dominated Cut Detection at 7.7G FLOPs

- **Source**: Cut Selection Trait SS6.4
- **Minimal viable impact**: **None**. The dominated strategy is not in the minimal viable solver. Level-1 is the selected cut selection variant (Implementation Ordering section 6). The dominated strategy should be gated behind a Cargo feature flag when eventually implemented.
- **Classification**: Post-MVP optimization concern. No action needed before or during coding.

### 4.2 `Result`-Returning Hot-Path Methods

- **Source**: Solver Interface Trait SS2.4
- **Minimal viable impact**: **Yes, affects coding but does not block it**. Every LP solve in the training loop calls `solve()` or `solve_with_basis()`, which return `Result<SolveStatus, SolverError>`. The `Result` is a zero-cost abstraction in the happy path (the compiler can optimize the branch away when the error variant is not constructed). However, the error-path benchmark requirement is valid: retry logic in Solver Abstraction SS7.1 adds latency when solves fail.
- **Classification**: Resolve-During-Phase (Phase 3). The implementer should run the error-path benchmark during initial HiGHS integration, before the training loop is assembled. The `Result` type is non-negotiable (the alternative -- `panic!` on solver error -- violates the retry contract). The risk is performance characterization, not API design.

### 4.3 LP Scaling Strategy Unresolved

- **Source**: Solver Abstraction SS3
- **Minimal viable impact**: **Resolved**. GAP-010 was resolved in gap-resolution epic-04 ticket-015: adopt `SolverAuto` (delegate scaling to HiGHS's internal scaling). No Cobre-managed scaling in the minimal viable solver. The performance risk is mitigated by relying on HiGHS's mature scaling implementation.
- **Classification**: Resolved. No further action needed.

### 4.4 Cut Pool Memory at 28 GB per Rank

- **Source**: Cut Management Implementation SS1.3
- **Minimal viable impact**: **No impact on coding; monitoring concern during integration testing**. The 28 GB estimate is for production scale (120 stages x 15,000 cuts x 2,080 state dims). The minimal viable solver will be tested with smaller cases first (the Phase 6 integration test specifies 3-bus, 2-hydro, 1-thermal, 12-stage). The pre-allocation formula is specified and implementable. The shared memory optimization (SharedRegion-based cut pool) is a post-MVP optimization.
- **Classification**: Post-MVP optimization concern. The implementer should add memory usage logging during Phase 6 integration testing to establish baselines, but the 28 GB figure does not block coding.

### 4.5 Missing Baseline Latency Targets

- **Source**: Production Scale Reference
- **Minimal viable impact**: **No impact on coding; affects CI regression detection**. Without wall-clock targets, the implementer cannot set performance regression gates. However, the minimal viable solver must work correctly before it can be fast. Latency targets should be established after the first end-to-end integration test (Phase 8).
- **Classification**: Post-MVP. Define targets after Phase 8 produces a working binary on production-scale data.

### 4.6 Performance Risk Summary

| Risk                                 | Affects Minimal Viable Coding? | Action Timing                       |
| ------------------------------------ | ------------------------------ | ----------------------------------- |
| Dominated cut detection (7.7G FLOPs) | No                             | Post-MVP (feature-gated)            |
| `Result` on hot path                 | Characterization only          | During Phase 3 (benchmark)          |
| LP scaling                           | Resolved (GAP-010)             | None                                |
| Cut pool memory (28 GB/rank)         | Monitoring only                | During Phase 6 (log memory)         |
| Missing latency targets              | No                             | After Phase 8 (establish baselines) |

**Conclusion**: No performance risk blocks minimal viable coding. One risk (Result on hot path) requires a benchmark during Phase 3 to characterize the overhead. All others are post-MVP concerns or already resolved.

## 5. Recommendation

### 5.1 Pre-Implementation Gap Resolution Plan: Required

Three gaps are classified as Resolve-Before-Coding. These must be resolved in the spec before their respective phases begin.

| Gap ID  | Description                                        | Affected Phase | Estimated Effort | Dependency                                            |
| ------- | -------------------------------------------------- | -------------- | ---------------- | ----------------------------------------------------- |
| GAP-020 | Output writer API (cobre-sddp to cobre-io handoff) | Phase 7        | 2-3 days         | Requires Phase 6 types to be sketched                 |
| GAP-023 | Opening tree Rust type and ownership model         | Phase 5        | 1-2 days         | Requires SharedMemoryProvider understanding (Phase 4) |
| GAP-029 | Cross-reference validation checklist completeness  | Phase 2        | 2-3 days         | Requires all entity specs to be audited               |

**Total estimated effort**: 5-8 working days for spec resolution.

### 5.2 Resolution Ordering

The three Resolve-Before-Coding gaps can be resolved in the following order, aligned with the phase dependency graph:

1. **GAP-029** (Phase 2 blocker): Enumerate all cross-reference validations. This can be done immediately since all entity specs and the data model are complete. Must be resolved before Phase 2 coding begins.

2. **GAP-023** (Phase 5 blocker): Define the opening tree type with SharedRegion integration. This requires understanding the SharedMemoryProvider trait (Phase 4 spec reading list) but does not require Phase 4 coding to be complete. Must be resolved before Phase 5 coding begins.

3. **GAP-020** (Phase 7 blocker): Define the SimulationWriter API. This depends on the simulation pipeline design (Phase 6) and output schema (Phase 2), so it can be resolved in parallel with Phase 6 coding. Must be resolved before Phase 7 coding begins.

### 5.3 Resolve-During-Phase Gaps: No Pre-Work Needed

The 12 Resolve-During-Phase gaps do not require pre-implementation spec work. Each can be resolved by the implementer as a local design decision during the relevant phase. However, two deserve early attention:

- **GAP-018** (threading model): The spec already recommends `rayon`. The implementer should confirm this choice during Phase 6 planning and document it in a brief ADR (Architecture Decision Record) rather than updating the spec.

- **GAP-026** (backward trial state distribution): Already clarified in Work Distribution SS2. The implementer should verify this when reading the Phase 6 spec reading list.

### 5.4 Resolve-After-MVP Gaps: No Action Needed

The 3 Resolve-After-MVP gaps (GAP-021, GAP-025, GAP-035) require no action before or during minimal viable implementation. GAP-021 is effectively already resolved (the FlatBuffers schema exists in full). GAP-025 and GAP-035 are documentation refinements.

### 5.5 Overall Assessment

The Medium and Low gaps do not present a systemic risk to the implementation plan. Only 3 of 18 gaps require pre-implementation spec resolution, and their combined effort (5-8 days) is modest. The remaining 15 gaps are either resolvable inline during implementation (12) or deferrable to post-MVP (3). No gap requires a fundamental spec redesign or reveals a missing architectural component.
