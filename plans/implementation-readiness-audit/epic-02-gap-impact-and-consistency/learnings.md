# Epic 02 Learnings: Gap Impact Assessment and Cross-Spec Consistency

## Patterns Established

- **Three-tier gap triage classification**: Resolve-Before-Coding (gap means an implementer cannot write a function signature or type definition), Resolve-During-Phase (gap is a local and reversible design choice), Resolve-After-MVP (gap affects a feature not in the minimal viable solver). This taxonomy is actionable because each tier maps to a concrete workflow: pre-coding spec work, inline implementation decision with optional ADR, or post-MVP deferred backlog. See the classification criteria table in `plans/implementation-readiness-audit/epic-02-gap-impact-and-consistency/report-009-gap-triage.md` section 1.

- **Phase-affinity tagging for gap triage**: each gap triage entry includes an "Affected Implementation Phase" tag, enabling the per-phase readiness assessment (Epic 03) to consume triage results directly without re-reading full rationale. This is an extension of the epic-01 "Affected Phase" tagging convention and applies to gap classification the same way it applied to crate audit findings. See section 2 of `report-009-gap-triage.md`.

- **Crate-boundary test for Resolve-Before-Coding**: the deciding question for the highest triage tier is always "does this gap affect a type or function signature that crosses a crate boundary?" If yes, Resolve-Before-Coding. If no (the gap is internal to one crate), Resolve-During-Phase is appropriate. GAP-023 (opening tree type) passed this test because cobre-stochastic generates it and cobre-sddp consumes it; GAP-018 (threading model) failed this test because both `rayon` and `std::thread` produce the same `train(...)` signature. See `report-009-gap-triage.md` entries for GAP-020, GAP-023, GAP-029.

- **Systematic link verification methodology for large spec corpora**: the cross-reference audit verified 4,689 internal Markdown links across 84 files using mdBook build output as the primary broken-link detector and manual section-number inspection as a secondary pass. Separating file-existence checks from section-number correctness checks is essential because mdBook does not validate section anchors -- a link can resolve as a file without its anchor being present. See `report-010-crossref-integrity.md` sections 2 and 3.

- **Canonical-snapshot comparison for shared type consistency**: each shared type audit began by extracting a "canonical snapshot" (all field names, types, variant names, invariants, byte offsets for repr(C) structs) from the single canonical source file and then comparing every reference site against that snapshot. The comparison is case-sensitive and field-by-field. References that operate at the type boundary level (function signatures only) are not flagged unless a field name or type conflicts. See `report-011-shared-types.md` Part 1 for each type's canonical snapshot table.

## Architectural Decisions

- **Only 3 of 18 remaining Medium/Low gaps require pre-coding spec work**: GAP-020 (output writer API), GAP-023 (opening tree Rust type), and GAP-029 (cross-reference validation checklist completeness). The other 15 gaps are either local design choices resolvable during implementation or effectively already resolved (GAP-021 FlatBuffers schema is fully present; GAP-026 work distribution is documented in Work Distribution SS2). The total pre-coding spec resolution effort is estimated at 5-8 working days. This finding is critical for epic-03 and epic-04 scoping: no additional spec-writing plan is needed before Phase 1-4 implementation begins; only Phases 5, 2, and 7 require pre-phase gap resolution. See `report-009-gap-triage.md` section 5.

- **GAP-021 was effectively self-resolved by the gap-resolution plan**: the FlatBuffers schema for cut persistence is fully present in `src/specs/data-model/binary-formats.md` SS3.1, defining all 8 tables with field types and defaults. The gap was filed against an earlier state of the spec and was not removed from the inventory after resolution. This suggests the gap-resolution plan's "resolution log" entries in `spec-gap-inventory.md` are not always reliably up to date. Future triage passes should re-read the referenced spec sections rather than relying solely on resolution log entries.

- **Convention violations in architecture files are pre-existing and widespread**: 83 non-blockquote `§` occurrences exist across 12 architecture files (all self-referential `§N` instead of `SSN`), plus 17 additional violations in 4 overview files (cross-architecture links using `§` instead of `SS`). These violations pre-date the convention established in epic-04 of the spec-readiness plan and were not caught because that plan's remediation focused only on the 6 trait specs with convention blockquotes. The violations are low severity (readability only, no link breakage) but widespread enough to require a dedicated batch-replacement ticket. They should not block implementation. See `report-010-crossref-integrity.md` section 5.

- **Cross-reference index is 2 substantive specs behind actual corpus**: `backend-testing.md` (480 lines, referenced by 8 other specs) and `ecosystem-guidelines.md` (441 lines) are absent from `src/specs/cross-reference-index.md`. The index claims 74 files; the correct count is 76 (excluding 7 mdBook section landing pages that are not independent specs). The absence of `backend-testing.md` is the higher-priority gap because 8 conformance testing specs cite it as an outgoing reference but the index records no incoming refs for it. See `report-010-crossref-integrity.md` section 4.

- **The single highest-severity finding in epic-02 is a stale API name carried over from epic-01**: Finding F3 in `report-011-shared-types.md` is the same `patch_rhs_bounds` -> `patch_row_bounds` stale name first identified in `report-004-cobre-solver.md` F-007 (epic-01). The 7 occurrences in `src/specs/architecture/solver-interface-testing.md` were not corrected during gap-resolution. This confirms the epic-01 finding that the testing spec is the most-at-risk spec for stale API names. The correction is mechanical (find and replace with one new method name and one additional section entry for `patch_col_bounds`) but must happen before the testing spec is used by an implementer.

- **Shared Rust struct types are consistent; mathematical notation is where the corpus has drift**: all 7 shared Rust types (System, StageTemplate, StageIndexer, CutWireRecord, TrainingEvent, LoadError, SolverError) passed the consistency check with zero field-level discrepancies. The inconsistencies are confined to mathematical notation in one file: `training-loop.md` SS7.1 uses `$\pi^a_{h,\ell}$` instead of the canonical `$\pi^{lag}_{h,\ell}$` (F1, medium severity) and `cut-management.md` uses `$p_h$` while all other specs use `$P_h$` (F2, low severity). This finding supports starting implementation with confidence in the Rust type layer while noting that `training-loop.md` SS7 should be corrected before the cut-coefficient extraction step (Phase 6) is implemented.

- **Broken links are localized to one file and one missing artifact**: all 3 broken links are in `src/specs/overview/production-scale-reference.md` and all reference the same non-committed artifact (`plans/spec-consistency-audit/epic-04-wall-clock-time-model/timing-model-analysis.md`). The artifact was an external reference used during authoring and not retained. The derivation logic is inline in the spec so no information is lost. Remedy is to remove the 3 Markdown link wrappers and leave the text as plain prose. See `report-010-crossref-integrity.md` section 2.

## Files and Structures Created

- `plans/implementation-readiness-audit/epic-02-gap-impact-and-consistency/report-009-gap-triage.md` -- Gap triage report for all 18 Medium and Low gaps. Contains: per-gap classification table (18 rows), summary statistics by classification and by phase, known performance risk assessment (5 risks), and resolution ordering recommendation. Key output: 3 Resolve-Before-Coding, 12 Resolve-During-Phase, 3 Resolve-After-MVP.

- `plans/implementation-readiness-audit/epic-02-gap-impact-and-consistency/report-010-crossref-integrity.md` -- Cross-reference integrity report for all 84 spec files and 4,689 Markdown links. Contains: mdBook build results (0 errors, pre-existing cosmetic HTML warnings), broken link inventory (3 links, 1 template placeholder), stale section reference inventory (2 confirmed, 1 misleading phrasing), cross-reference index delta (9 updates needed), convention violation tables (83 architecture violations, 17 overview violations).

- `plans/implementation-readiness-audit/epic-02-gap-impact-and-consistency/report-011-shared-types.md` -- Shared type consistency report for 7 Rust types and 3 mathematical notation families. Contains: per-type consistency matrix (7 types, all PASS), notation consistency matrix (3 families, 2 FAIL), 3 numbered findings (F1 medium, F2 low, F3 high), and priority-ordered recommendation. Overall verdict: REJECTED (4/7 type criteria passed after accounting for notation families; all Rust struct types are consistent but notation families N1 and N3 failed).

## Conventions Adopted

- **Phase-column requirement in triage tables**: every gap triage row must include the implementation phase it affects, not just the crate. The phase column enables direct consumption by the epic-03 phase readiness assessment without re-reading crate audit reports. Gaps affecting multiple phases are listed with a range (e.g., "Phase 5 primarily, Phase 6 consumer").

- **"Crate boundary" as the bright-line Resolve-Before-Coding test**: the triage classification decision is deterministic when framed as: does this gap prevent writing a public function signature or type definition that another crate will import? If yes, Resolve-Before-Coding. This is a more precise version of the "Must / Should / May" priority tiers from epic-01 and should supersede subjective severity assessment in future gap triage tickets.

- **Canonical snapshot extraction before cross-reference checking**: for type consistency audits, always extract the full canonical snapshot (fields, types, variants, constraints) from the designated canonical source file before reading any referencing file. This prevents anchoring bias where a stale reference gets implicitly treated as authoritative because it is read first. The canonical source files are documented in the ticket specs and should be preserved in future ticket context.

- **Distinguish mdBook link resolution from section-anchor existence**: mdBook build output detects broken file-level links but not broken section anchors. Section-anchor verification requires extracting heading slugs manually and comparing them against link text. The gap-resolution plan's `N.Ma` lettering convention for new subsections (e.g., SS2.1b) is safe because mdBook slugifies heading text character by character; `2.1b` becomes the anchor `21b` and is reachable. Verify this during any future batch of new subsection additions.

- **Template placeholder links are not defects**: `src/specs/overview/ecosystem-guidelines.md` contains a `[File](./link.md)` template placeholder that is intentional (part of the authoring checklist template). It should not be flagged as a broken link in future audits. A comment or `<!-- template -->` annotation in the source file would prevent future false positives.

## Surprises and Deviations

- **GAP-026 (backward pass trial state distribution) was already resolved in the spec before the triage ran**: the Work Distribution spec SS2 contains a clear statement that trial points are distributed using the same static contiguous block assignment as the forward pass. The gap was listed as open in `spec-gap-inventory.md` but the referenced spec section had already been updated. This is the second gap discovered during triage to be effectively resolved (alongside GAP-021). The gap inventory is lagging behind the actual spec state by at least 2 entries, which suggests the resolution log update discipline broke down near the end of the gap-resolution plan.

- **All 7 shared Rust types passed consistency checks, which was more positive than expected**: given the scale of the gap-resolution plan (25 tickets modifying ~30 spec files), the expectation was to find at least one Rust type inconsistency. The "one canonical source + cross-references only" convention, enforced throughout the gap-resolution plan, appears to have been effective. Files that reference shared types consistently either defer to the canonical source or operate at the type boundary level without re-listing fields.

- **The `patch_rhs_bounds` stale name is the only case where a gap-resolution propagation explicitly failed**: the GAP-009 resolution log states "All cross-references updated" but the testing spec retains 7 occurrences of the old name. The other 4 affected files were correctly updated. The testing spec appears to have been missed. This is a single-file propagation failure, not a systematic failure, but it is the highest-severity finding in the epic because it will directly mislead an implementer.

- **Mathematical notation inconsistencies originate from one file** (`training-loop.md` SS7): the two notation findings (F1 and F3 overlapping, plus F2 in `cut-management.md`) are concentrated rather than distributed across the corpus. This suggests the `training-loop.md` SS7 content was authored with different notation conventions than the math specs, possibly because SS7 (dual normalization and sign convention) was added during a revision that did not cross-reference `cut-management.md` SS1 closely enough. The fix is isolated to one section of one file plus one section of `cut-management.md`.

- **83 `§` convention violations in architecture files is larger than expected for a corpus that passed epic-04's convention enforcement**: the epic-04 remediation in the spec-readiness plan specifically targeted convention compliance, and the CLAUDE.md project instructions state "post-epic-04 state: `grep § src/specs/architecture/` returns only blockquote occurrences in the 7 trait specs." This was not correct. The 83 violations are all in non-trait architecture files that were not audited during epic-04, which focused exclusively on the 7 trait specs. The CLAUDE.md baseline claim was narrower than it appeared and should be corrected.

## Aggregate Statistics

- Total gaps triaged: 18 (13 Medium, 5 Low)
- Classifications: 3 Resolve-Before-Coding, 12 Resolve-During-Phase, 3 Resolve-After-MVP
- Gaps discovered to be already resolved: 2 (GAP-021, GAP-026)
- Performance risks affecting minimal viable coding: 1 (Result on hot path requires Phase 3 benchmark; no coding blocker)
- Total Markdown links verified: 4,689 across 84 spec files
- Broken file-level links: 3 (all in same file, same missing artifact)
- Stale section references: 2 confirmed, 1 misleading phrasing
- Cross-reference index gaps: 2 missing specs (backend-testing.md, ecosystem-guidelines.md)
- Convention violations: 83 in 12 architecture files, 17 in 4 overview files
- Shared type consistency: 7/7 Rust types PASS, 1/3 notation families PASS
- Distinct findings: 3 (F1 medium notation, F2 low notation, F3 high stale API name)
- mdBook build errors: 0
- Pre-existing build warnings: 20 (10 unclosed span pairs in specs/math/risk-measures.md, unchanged from prior state)

## Recommendations for Future Epics

- **Epic-03 phase readiness assessment should use the triage results directly**: the phase column in `report-009-gap-triage.md` section 3.2 gives a ready-made per-phase gap count. Phase 6 (cobre-sddp training) has 8 Resolve-During-Phase gaps -- the largest concentration -- but 0 Resolve-Before-Coding gaps, making it the most implementation-ready phase from a gap perspective. Phase 2 (cobre-io) and Phase 5 (cobre-stochastic) each have 1 Resolve-Before-Coding gap that must be resolved before the phase starts. See `report-009-gap-triage.md` section 3.2.

- **Epic-03 or epic-04 must include a dedicated convention cleanup ticket for the 83 + 17 `§` violations**: the 100 violations spread across 16 files are a readability defect for implementers reading the specs and a maintenance defect for authors updating them. The fix is a batch `sed` replacement (architecture files: `§N` -> `SSN`; overview files: `§N` for architecture links -> `SSN`). This should be scoped as a single low-effort ticket in epic-03 or epic-04, not bundled with other changes. Reference `report-010-crossref-integrity.md` section 5 for the file-by-file violation counts.

- **F3 (`patch_rhs_bounds` in solver-interface-testing.md) must be resolved before epic-03 test adequacy assessment**: the test adequacy audit in epic-03 will read `solver-interface-testing.md` as its primary input for cobre-solver testing coverage. If F3 is still present, the audit will encounter test names and section headings that reference a non-existent method, making coverage assessment misleading. Fix F3 first, then audit. See `report-011-shared-types.md` Finding F3 for the exact 7 line numbers.

- **The cross-reference index update (2 missing specs, 9 index changes) is a low-effort, high-value fix**: the 9 updates needed are mechanical (add 2 rows to section 1, update 11 per-crate reading lists in section 2, add rows to sections 3 and 4, update section 5 position). This should be bundled into a single ticket. The primary value is that `backend-testing.md` gains an incoming-reference row so the index accurately reflects the 8 conformance testing specs that depend on it. See `report-010-crossref-integrity.md` section 4.5 for the complete required-updates table.

- **Epic-04 verdict synthesis should note GAP-020 (output writer API) as the highest-priority remaining pre-coding spec gap**: of the 3 Resolve-Before-Coding gaps, GAP-020 affects Phase 7 (the last integration phase) and requires the most effort (2-3 days) because it involves defining a new crate boundary API. GAP-023 (opening tree, Phase 5, 1-2 days) and GAP-029 (cross-reference validation checklist, Phase 2, 2-3 days) are lower-risk. The verdict ticket should present these as pre-coding conditions with explicit resolution ordering. See `report-009-gap-triage.md` section 5.2.

- **Notation corrections F1 and F2 should be fixed before Phase 6 implementation tickets are written**: `training-loop.md` SS7.1 uses `$\pi^a_{h,\ell}$` while `cut-management.md` uses `$\pi^{lag}_{h,\ell}$`. An implementer writing cut coefficient extraction (Phase 6) will read both specs and encounter two symbols for the same quantity. The correction is: (a) update `training-loop.md` SS7.1 lines 804, 812-813, 822, 829 to replace `\pi^a` with `\pi^{lag}`; (b) update `cut-management.md` SS1 lines 12 and 37 to replace `p_h` with `P_h`. These are two-minute edits. See `report-011-shared-types.md` Findings F1 and F2.
