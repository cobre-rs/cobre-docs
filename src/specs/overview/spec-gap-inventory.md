# Spec Gap Inventory

## 1. Purpose

This document catalogs every specification gap that would block, delay, or compromise the implementation of the minimal viable SDDP solver as defined in [Implementation Ordering](./implementation-ordering.md). Each gap identifies missing information, ambiguous behavior, undefined interfaces, or underspecified edge cases across the eight required crates (cobre-core, cobre-io, cobre-stochastic, cobre-solver, cobre-sddp, cobre-comm, cobre-cli, ferrompi). The inventory is the starting point for a targeted resolution effort prior to and during coding.

## 2. Scope and Classification

**Scope.** This inventory covers only the minimal viable solver: the eight crates listed in [Implementation Ordering](./implementation-ordering.md) section 4, the four fully-modeled system element types (Bus, Line, Thermal, Hydro), constant hydro productivity, single-cut formulation, Expectation risk measure, Level-1 cut selection, Finite horizon mode, InSample sampling scheme, all five stopping rules, HiGHS solver backend, and MPI communicator backend. Deferred features (Python bindings, TUI, MCP server, TCP/shm backends, CVaR, Cyclic horizon, LML1, External/Historical sampling, CLP solver, multi-cut, FPHA, GNL, batteries, non-convex simulation extensions, complete tree mode) are explicitly out of scope and are NOT flagged as gaps.

**Architectural hooks.** While deferred features themselves are not gaps, architectural hooks that enable future addition of deferred features ARE evaluated. If a hook is underspecified in a way that could force a breaking change when the feature is added, it is logged.

**Severity levels.**

| Severity | Definition                                                                                                                                   | Action Required       |
| -------- | -------------------------------------------------------------------------------------------------------------------------------------------- | --------------------- |
| Blocker  | Cannot proceed without resolving. Missing information, contradictions, or undefined interfaces that prevent writing correct code.            | Before coding starts  |
| High     | Can start but blocked before completion. Ambiguous behavior, missing edge cases, or incomplete type definitions that will block integration. | During implementation |
| Medium   | Can complete but may be incorrect or suboptimal. Missing performance constraints, unclear defaults, or unspecified recovery behavior.        | During implementation |
| Low      | Can complete correctly. Missing documentation, unclear rationale, or cosmetic issues that do not affect correctness.                         | Opportunistically     |

## 3. Gap Inventory Table

| ID      | Severity | Affected Crate(s)            | Spec File(s)                                                                                                                     | Section(s)          | Description                                                                                                                                                                                                                                                                                                                                                                                                                                           | Resolution Path                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| ------- | -------- | ---------------------------- | -------------------------------------------------------------------------------------------------------------------------------- | ------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| GAP-001 | Blocker  | cobre-core, cobre-sddp       | [Internal Structures](../data-model/internal-structures.md)                                                                      | 1, 2                | **Resolved.** The `SystemRepresentation` top-level type that holds all entity collections, metadata, and cascade topology is described only narratively. No struct sketch, no public API surface, and no method signatures for querying entities by ID or iterating in canonical order. All downstream crates depend on this type.                                                                                                                    | **Resolved** -- `SystemRepresentation` struct sketch defined in [Internal Structures](../data-model/internal-structures.md) SS1.1--1.7, with public accessors, entity-count queries, cascade topology lookup, and `Send + Sync` bounds.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| GAP-002 | Blocker  | cobre-core, cobre-sddp       | [Internal Structures](../data-model/internal-structures.md), [LP Formulation](../math/lp-formulation.md)                         | 2, 3                | **Resolved.** The operative state machine (Non-existing, Filling, Operating, Decommissioned) is defined but the Decommissioned state references an "open question" in [Input System Entities](../data-model/input-system-entities.md) section 3. The LP treatment of Decommissioned entities is undefined -- does it match Non-existing (zero variables), or does it have residual constraints (e.g., reservoir drainage)?                            | **Resolved** -- Decommissioned is treated identically to Non-existing (zero variables, zero constraints), documented in [Internal Structures](../data-model/internal-structures.md) SS2. Open question closed.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| GAP-003 | Blocker  | cobre-io, cobre-core         | [Input Loading Pipeline](../architecture/input-loading-pipeline.md)                                                              | 6                   | **Resolved.** The broadcast strategy states data is "serialized to contiguous byte buffers for MPI broadcast" but does not specify the serialization format. Is this `bincode`, `rkyv`, `postcard`, manual `unsafe` transmute of `#[repr(C)]` types, or something else? The choice affects cobre-core type design (must be serializable) and cobre-io implementation.                                                                                 | **Resolved** -- `postcard` serialization adopted for MPI broadcast (replacing earlier `rkyv` decision), documented in [Input Loading Pipeline](../architecture/input-loading-pipeline.md) SS6.1--6.4. `serde::Serialize + serde::Deserialize` bounds sufficient; no additional derives required beyond existing serde support.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| GAP-004 | Blocker  | cobre-sddp, cobre-solver     | [Solver Abstraction](../architecture/solver-abstraction.md), [Solver Interface Trait](../architecture/solver-interface-trait.md) | 3, 4.4              | **Resolved.** The `StageTemplate` struct is defined in the solver interface trait but the construction process (how cobre-sddp builds a `StageTemplate` from `InternalStructures` + `StageDefinition`) is not specified. This is the bridge between the data model and the LP solver. Which crate owns this construction? What is the public API?                                                                                                     | **Resolved** -- LP memory layout with exact column index formulas (SS2.1) and row index formulas (SS2.2) in [Solver Abstraction](../architecture/solver-abstraction.md) SS2; `StageTemplate` construction ownership and type signature in [Solver Interface Trait](../architecture/solver-interface-trait.md) SS4.4. Worked example for a 3-hydro AR(2) system in [Solver Abstraction](../architecture/solver-abstraction.md) SS2.4.                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| GAP-005 | Blocker  | cobre-sddp                   | [Training Loop](../architecture/training-loop.md), [Solver Abstraction](../architecture/solver-abstraction.md)                   | 4.2, 11.2           | **Resolved.** The forward pass step "Build stage LP" (step c) references building the LP with "incoming state, scenario realization, and all current FCF cuts" but the exact sequence of `patch_rhs_bounds` calls is unspecified. How many patches per stage? Which constraint indices receive which values (storage RHS, AR lag fixing, noise fixing)? The LP layout convention defines regions but not the exact index arithmetic.                  | **Resolved** -- State vector format, concrete type definition, and `StageIndexer` struct in [Training Loop](../architecture/training-loop.md) SS5 (SS5.1--5.5); forward pass patch sequence with exact row index formulas, patch count formula $N \cdot (2 + L)$, and worked 3-hydro AR(2) example in [Training Loop](../architecture/training-loop.md) SS4.2a; row layout index arithmetic in [Solver Abstraction](../architecture/solver-abstraction.md) SS2.2.                                                                                                                                                                                                                                                                                                                                                                                                                |
| GAP-006 | High     | cobre-sddp                   | [Training Loop](../architecture/training-loop.md)                                                                                | 5.2, 6.1            | **Resolved.** The forward pass collects visited states across all ranks via `allgatherv` (section 5.2 step 3), but the exact wire format for state vectors is unspecified. Is it a flat `[f64]` with implicit indexing (scenario-major or stage-major)? How are counts and displacements computed from per-rank scenario assignments?                                                                                                                 | **Resolved** -- Raw `[f64]` wire format with scenario-major indexing, one `allgatherv` per stage, `counts[r] = M_r * n_state`, `displs[r] = sum(counts[0..r])`, no alignment padding, production sizing 192 x 2,080 x 8 = 3.19 MB per stage. Specified in [Training Loop](../architecture/training-loop.md) SS5.4a.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| GAP-007 | High     | cobre-sddp                   | [Cut Management Implementation](../architecture/cut-management-impl.md)                                                          | 4.2                 | **Resolved.** The MPI wire format for cut synchronization is specified per-cut (slot index, iteration, forward pass index, intercept, coefficients) but the endianness convention, alignment requirements, and whether this is a raw byte reinterpretation or a structured serialization are unspecified.                                                                                                                                             | **Resolved** -- `#[repr(C)]` `CutWireRecord` struct with native endianness (same-architecture assumption), 4-byte explicit `_padding` for 8-byte `f64` alignment, `allgatherv` over `T = u8` raw bytes, exact per-cut size $24 + n_{state} \times 8$ (16,664 bytes at production scale), no version byte. Specified in [Cut Management Implementation](../architecture/cut-management-impl.md) SS4.2a.                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| GAP-008 | High     | cobre-sddp                   | [Training Loop](../architecture/training-loop.md)                                                                                | 7.2                 | **Resolved.** Cut coefficient computation references "AR lag fixing constraints" whose duals are extracted, but the AR lag fixing constraints are not defined in [LP Formulation](../math/lp-formulation.md). The LP formulation shows the AR dynamics equation but not the separate fixing constraints that bind lag variables to incoming state values. These constraints and their LP row positions must be specified for correct dual extraction. | **Resolved** -- AR lag fixing constraints promoted to formal constraint family section SS5a in [LP Formulation](../math/lp-formulation.md): $N \times L$ equality constraints $a_{h,\ell} = \hat{a}_{h,\ell}$ with dual $\pi^{lag}_{h,\ell}$ as cut coefficient. Cross-references to [Solver Abstraction](../architecture/solver-abstraction.md) SS2.2, [Training Loop](../architecture/training-loop.md) SS4.2a and SS7.2.                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| GAP-009 | High     | cobre-solver                 | [Solver Interface Trait](../architecture/solver-interface-trait.md)                                                              | 2.3                 | **Resolved.** `patch_rhs_bounds` accepted `&[(usize, f64)]` but the semantics were ambiguous: does the `usize` index refer to row indices (for RHS patching) or column indices (for bound patching)? The method description said "RHS values and variable bounds" but the signature had a single flat array. HiGHS uses separate APIs for row bounds and column bounds.                                                                               | **Resolved** -- Split into two methods: `patch_row_bounds(&mut self, patches: &[(usize, f64, f64)])` for row lower/upper (SS2.3) and `patch_col_bounds(&mut self, patches: &[(usize, f64, f64)])` for column lower/upper (SS2.3a). HiGHS and CLP API mappings documented. All cross-references updated.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| GAP-010 | High     | cobre-sddp, cobre-solver     | [Solver Abstraction](../architecture/solver-abstraction.md)                                                                      | 3, open point       | **Resolved.** The LP scaling strategy is explicitly deferred as an "open point." For the minimal viable solver, is single-phase scaling adopted as the baseline, or is no scaling applied? If no scaling, the risk of numerical difficulties on production-scale problems is elevated.                                                                                                                                                                | **Resolved** -- Adopt `SolverAuto` (delegate scaling to solver backend) as the baseline for the minimal viable solver. HiGHS and CLP internal scaling enabled by default. Cobre-managed scaling and two-phase scaling deferred to a later optimization pass. Decision in [Solver Abstraction](../architecture/solver-abstraction.md) SS3.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| GAP-011 | High     | cobre-sddp, cobre-solver     | [Solver Abstraction](../architecture/solver-abstraction.md)                                                                      | 5.4, open question  | **Resolved.** The "selective vs bulk cut loading" strategy is explicitly deferred as an "open question." The current baseline (selective addition) is described but not formally adopted. This affects `CutBatch` assembly logic and solver configuration (presolve on/off).                                                                                                                                                                          | **Resolved** -- Adopt selective cut addition as the baseline for the minimal viable solver. Only active cuts (per activity bitmap) added via `addRows`; inactive cuts excluded from solver LP entirely. Bulk loading with bound deactivation deferred. `CutBatch` assembly cost $O(n_\text{active} \times n_\text{state})$. Decision in [Solver Abstraction](../architecture/solver-abstraction.md) SS5.4.                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| GAP-012 | High     | cobre-core, cobre-io         | [Input Loading Pipeline](../architecture/input-loading-pipeline.md), [Internal Structures](../data-model/internal-structures.md) | 8, 1                | **Resolved.** The "transition to in-memory model" section states that the in-memory structures are "not specified here" and defers to Internal Structures, which in turn describes the logical model without implementation types. The actual Rust struct definitions that cobre-io produces and cobre-core holds are undefined. Neither spec provides the concrete type that crosses the crate boundary.                                             | **Resolved** -- `load_case` public API with full function signature, `LoadError` enum (5 variants: `IoError`, `ParseError`, `SchemaError`, `CrossReferenceError`, `ConstraintError`), responsibility boundary (SS2.1--2.6, excludes policy loading), owned `System` return type, and cross-references to Internal Structures SS1 and CLI and Lifecycle SS5.2. Specified in [Input Loading Pipeline](../architecture/input-loading-pipeline.md) SS8.1. Cross-reference in [Internal Structures](../data-model/internal-structures.md) SS1.7 updated to point to SS8.1.                                                                                                                                                                                                                                                                                                            |
| GAP-013 | High     | cobre-sddp                   | [Training Loop](../architecture/training-loop.md)                                                                                | 2.1a                | **Resolved.** Event types (`ForwardPassComplete`, `BackwardPassComplete`, `ConvergenceUpdate`, etc.) are listed with payload summaries but no Rust type definitions are provided. The spec says "Event types are defined in `cobre-core`" but no event enum or struct definitions appear in any cobre-core spec.                                                                                                                                      | **Resolved** -- `TrainingEvent` enum with 11 variants (7 per-iteration + 4 lifecycle) and typed payload structs defined in [Training Loop](../architecture/training-loop.md) SS2.1b. Crate assignment: cobre-core. Helper struct `StoppingRuleResult` for `ConvergenceUpdate.rules_evaluated`. Derives `Clone + Debug` only (no `Send + Sync`). Events carry no per-event timestamps; consumers timestamp on receipt.                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| GAP-014 | High     | cobre-stochastic, cobre-sddp | [Scenario Generation](../architecture/scenario-generation.md)                                                                    | 2.2                 | **Resolved.** Reproducible sampling requires a "deterministic hash function" to derive per-(iteration, scenario, stage) seeds from a base seed, but the hash function is not specified. The choice of hash function affects reproducibility guarantees across platforms and Rust compiler versions.                                                                                                                                                   | **Resolved** -- SipHash-1-3 via `siphasher` crate 1.x (not `DefaultHasher`), little-endian fixed-width input encoding (20 bytes for forward pass, 16 bytes for opening tree), 64-bit hash output seeding `Pcg64` RNG. Non-cryptographic. Native endianness rejected for cross-platform reproducibility. Specified in [Scenario Generation](../architecture/scenario-generation.md) SS2.2a.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| GAP-015 | High     | cobre-sddp                   | [Convergence Monitoring](../architecture/convergence-monitoring.md)                                                              | 1                   | **Resolved.** The simulation-based stopping rule (section 2.3 step 4) requires running Monte Carlo simulations during training to assess policy stability, but the interaction with the main training loop is underspecified. Does the simulation reuse the training LP infrastructure? Does it block the training loop? How many threads does it consume? Where do the simulation scenarios come from?                                               | **Resolved** -- Simulation-based stopping rule integration specified in [Convergence Monitoring](../architecture/convergence-monitoring.md) SS2.3a. Synchronous (blocking) execution within Training Loop SS2.1 step 5. Reuses training solver workspaces (no separate LP instances). Fresh InSample draws from fixed opening tree with separate seed derived via `base_seed + iteration` and SipHash-1-3 (Scenario Generation SS2.2a). `replications` scenarios distributed via contiguous block assignment (Training Loop SS4.3). All OpenMP threads participate. First check stores baseline without triggering convergence. ~840 LP solves per rank, ~1.7s at production scale.                                                                                                                                                                                              |
| GAP-016 | High     | cobre-cli                    | [CLI and Lifecycle](../architecture/cli-and-lifecycle.md)                                                                        | 5.2a                | **Resolved.** The CLI spec is referenced in the implementation ordering but was not included in the reading list for this ticket. The spec file exists but key details about the `run` subcommand's interaction with MPI initialization, config resolution order, and the exact phase boundaries (which phases are rank-0 only, which are all-ranks) must be verified against the training loop spec.                                                 | **Resolved** -- Phase-Training Loop alignment table added to [CLI and Lifecycle](../architecture/cli-and-lifecycle.md) SS5.2a. All 7 phases mapped to authoritative spec sections with ordering constraints. Audit confirmed: MPI init is first operation in Startup, rank-0 `load_case` in Validation precedes rkyv broadcast in Initialization, solver workspace allocation and stage template construction complete before Training, scenario generation (PAR preprocessing + opening tree) precedes Training. No inconsistencies found; existing phase ordering was already correct.                                                                                                                                                                                                                                                                                         |
| GAP-017 | High     | ferrompi                     | [Hybrid Parallelism](../hpc/hybrid-parallelism.md), [Backend: Ferrompi](../hpc/backend-ferrompi.md)                              | 2.1                 | **Resolved.** The ferrompi crate API surface is described indirectly through the `FerrompiBackend` wrapper but the ferrompi crate itself has no standalone API specification. Methods like `Mpi::init_thread`, `allgatherv`, `allreduce`, `broadcast`, `barrier`, `SharedWindow::allocate`, `SharedWindow::remote_slice`, `SharedWindow::fence` are referenced but their exact Rust signatures, error types, and `unsafe` boundaries are unspecified. | **Resolved** -- Standalone ferrompi API reference added to [Backend: Ferrompi](../hpc/backend-ferrompi.md) SS7. Updated to match the real ferrompi 0.1 crate API. Documents `Mpi` struct (init/init_thread/world/Drop), `Communicator` (rank, size, allgatherv, allreduce, broadcast, barrier, split_shared, allreduce_init + summary of 60+ methods), `SharedWindow<T>` (allocate, local_slice, local_slice_mut, remote_slice, fence, lock/lock_all, Drop), supporting types (`ThreadLevel`, `ReduceOp`, `MpiDatatype` sealed trait, `DatatypeTag`, `Error` enum, `MpiErrorClass` with 24+ variants, `SplitType`, `Request`, `PersistentRequest`). Unsafe boundary summary (SS7.5) confirms no public methods are Rust `unsafe`. `SharedWindow::remote_slice` logical safety contract (fence-before-read) documented in SS7.3.3.                                                |
| GAP-018 | Medium   | cobre-sddp                   | [Training Loop](../architecture/training-loop.md)                                                                                | 4.3                 | The "thread-trajectory affinity" pattern for the forward pass states that each OpenMP thread owns complete trajectories, but the OpenMP integration strategy for Rust is unspecified. Rust does not natively support OpenMP. Will this use `rayon`, `std::thread` with manual affinity, or FFI to OpenMP via C? The parallelism model affects every performance-critical code path.                                                                   | Specify the threading model: recommend `rayon` with a custom thread pool sized to match NUMA topology, or `std::thread::scope` with explicit pinning. Document the decision and its implications for work-stealing vs. static partitioning.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| GAP-019 | Medium   | cobre-sddp                   | [Solver Abstraction](../architecture/solver-abstraction.md)                                                                      | 7.1                 | The retry logic contract specifies "maximum attempts: 5" and "time budget" as defaults, but no configuration parameters for these appear in [Configuration Reference](../configuration/configuration-reference.md). The retry policy is hardcoded behavior with no user override path.                                                                                                                                                                | Add `solver.retry_max_attempts` and `solver.retry_time_budget_seconds` to the configuration reference. Alternatively, document that these are implementation-internal constants not exposed to users.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| GAP-020 | Medium   | cobre-io                     | [Output Schemas](../data-model/output-schemas.md), [Output Infrastructure](../data-model/output-infrastructure.md)               | 1                   | **Resolved.** The output directory structure and Parquet schemas are well-defined, but the API for writing output from cobre-sddp is unspecified. Does cobre-sddp call cobre-io functions directly? Is there a writer trait? What is the function signature for streaming simulation results? The crate boundary between cobre-sddp (producer) and cobre-io (writer) needs an explicit interface.                                                     | **Resolved** -- Output writer API defined in [Output Infrastructure](../data-model/output-infrastructure.md) SS6. Nine API elements specified: `SimulationParquetWriter` (SS6.2), `TrainingParquetWriter` (SS6.3), `OutputError` enum with 4 variants (SS6.4), manifest/metadata/dictionary standalone functions (SS6.5), `write_policy_checkpoint` (SS6.6), anchoring `write_results` function (SS6.1). Parquet library: `arrow-rs`. Separate concrete writers (not a trait). `SimulationParquetWriter` is `Send` for I/O thread transfer. serde derives on manifest/metadata structs. FlatBuffers uses generated code.                                                                                                                                                                                                                                                         |
| GAP-021 | Medium   | cobre-io                     | [Binary Formats](../data-model/binary-formats.md)                                                                                | 3                   | The FlatBuffers schema for cut persistence is referenced but not provided in full. The spec describes the schema conceptually (StageCuts, BendersCut, StageBasis) but the actual `.fbs` schema file that would be used for code generation is not included.                                                                                                                                                                                           | Include the complete FlatBuffers `.fbs` schema definition in the spec, or create a dedicated schema file referenced from the spec. This is needed for `flatc` code generation during implementation.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| GAP-022 | Medium   | cobre-stochastic             | [Scenario Generation](../architecture/scenario-generation.md)                                                                    | 1.2, 1.3            | The PAR preprocessing pipeline produces contiguous arrays (`base`, `coefficients`, `scales`, `orders`) but the concrete Rust types that hold these arrays are unspecified. Is this a single struct? Multiple arrays? Does it own the data or borrow from cobre-core? This is the primary data structure that cobre-stochastic exposes to cobre-sddp.                                                                                                  | Define a `PrecomputedPar` struct with owned contiguous arrays. Specify the public constructor `fn precompute_par(system: &System, stages: &[Stage]) -> PrecomputedPar` and the runtime evaluation method `fn evaluate(&self, stage: usize, hydro: usize, lags: &[f64], noise: f64) -> f64`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| GAP-023 | Medium   | cobre-stochastic, cobre-sddp | [Scenario Generation](../architecture/scenario-generation.md)                                                                    | 2.3                 | **Resolved.** The opening tree is described as a 3D array `(T x N_openings x N_entities)` stored in opening-major order, but the Rust type and ownership model are unspecified. Is this a `Vec<f64>` with manual indexing? An `ndarray::Array3`? A `SharedRegion<f64>` from cobre-comm? The type crosses the cobre-stochastic/cobre-sddp boundary.                                                                                                    | **Resolved** -- `OpeningTree` struct with flat `Box<[f64]>` storage and per-stage variable branching defined in [Scenario Generation](../architecture/scenario-generation.md) SS2.3a. Per-stage branching factor `openings_per_stage: Box<[usize]>` sourced from `StageSamplingConfig.num_scenarios`; cumulative `stage_offsets` for O(1) access. Accessor method `fn opening(&self, stage: usize, opening_idx: usize) -> &[f64]` with offset-based indexing. `fn n_openings(&self, stage: usize) -> usize` returns per-stage count. `OpeningTreeView<'a>` borrow type for training loop consumption. Forward/backward separation clarified: `OpeningTree` is the backward pass structure; forward pass uses it only via `InSample` scheme. Uniform branching is the common degenerate case. Ownership strategy analysis deferred to implementation (not a behavioral contract). |
| GAP-024 | Medium   | cobre-sddp                   | [Cut Management Implementation](../architecture/cut-management-impl.md)                                                          | 6.1                 | Cut activity tracking requires detecting which cuts are "binding" after each LP solve by checking if the cut's dual multiplier is positive. The tolerance for "positive" is described as "configurable" but no default value or configuration parameter is specified.                                                                                                                                                                                 | Add a `cut_activity_tolerance` parameter to the configuration reference with a default of `1e-6`. Document that this tolerance determines whether a cut is considered binding for Level-1 selection.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| GAP-025 | Medium   | cobre-core, cobre-sddp       | [Penalty System](../data-model/penalty-system.md), [LP Formulation](../math/lp-formulation.md)                                   | 2, 1.5              | The penalty priority ordering is specified qualitatively but no quantitative validation rule exists. A user could set `deficit_cost < spillage_cost`, violating the ordering. Should the loader warn, error, or silently accept? The spec says the ordering "must be maintained" but does not specify enforcement.                                                                                                                                    | Add a validation rule in the input loading pipeline that checks penalty priority ordering and emits a warning (not error) if violated. Document that violations may cause suboptimal policy behavior but do not break algorithmic correctness.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| GAP-026 | Medium   | cobre-sddp                   | [Training Loop](../architecture/training-loop.md)                                                                                | 6.3                 | The backward pass states "trial states at each stage are distributed across MPI ranks" but the distribution strategy is not specified. Is it contiguous block assignment (like forward scenarios) or round-robin? When the number of trial states differs from the number of forward passes (e.g., after deduplication in future), how is load balancing handled?                                                                                     | Specify contiguous block assignment for backward trial state distribution, consistent with the forward pass pattern. Document that all ranks receive the same set of trial states via `allgatherv` and each rank processes its assigned subset.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| GAP-027 | Medium   | cobre-cli, cobre-sddp        | [Configuration Reference](../configuration/configuration-reference.md)                                                           | 3.1                 | The `training.forward_passes` parameter has no documented default value (the table shows "---"). This is a mandatory parameter for the training loop. Should the loader reject configs without it, or should there be a sensible default?                                                                                                                                                                                                             | Specify that `training.forward_passes` is required (no default) and the loader emits an error if it is missing. Alternatively, define a default based on MPI rank count (e.g., `max(1, n_ranks)`).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| GAP-028 | Medium   | cobre-sddp                   | [Simulation Architecture](../architecture/simulation-architecture.md)                                                            | 2                   | Policy compatibility validation is described as a "hard error" on mismatch, but the full validation specification is deferred to [Deferred Features SSC.9](../deferred.md). For the minimal viable solver, where training and simulation run in the same execution, is policy compatibility validation still needed? If warm-start is supported, it is needed.                                                                                        | Clarify scope: if warm-start is in the minimal viable (it is, per implementation ordering Phase 7), define the minimal set of compatibility checks inline (state dimension, hydro count, AR orders). Defer the full validation algorithm but implement the minimal checks.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| GAP-029 | Medium   | cobre-io                     | [Input Loading Pipeline](../architecture/input-loading-pipeline.md)                                                              | 2.6                 | **Resolved.** Cross-reference validation lists specific checks but notes the list is "illustrative, not exhaustive." For implementation, the developer needs a complete, enumerated list of cross-reference checks.                                                                                                                                                                                                                                   | **Resolved** -- Exhaustive 26-rule cross-reference validation checklist added to [Input Loading Pipeline](../architecture/input-loading-pipeline.md) SS2.6. Covers all `_id` foreign-key fields across 7 entity types (Line, Thermal, Hydro, PumpingStation, EnergyContract, NonControllableSource, GenericConstraint), structural checks (cascade DAG acyclicity, self-loop/self-pump prevention), coverage checks (initial conditions, inflow model, FPHA hyperplanes), and policy graph stage references. Each rule specifies source entity, reference field, target entity, validation rule, and `LoadError` variant.                                                                                                                                                                                                                                                        |
| GAP-030 | Medium   | cobre-sddp                   | [Training Loop](../architecture/training-loop.md)                                                                                | 4.2                 | The forward pass step "Record" (step e) says to store "the stage cost and the end-of-stage state" but does not specify the data structure for per-scenario trajectory records. Is this a flat array? A struct per stage? How is it indexed for the backward pass?                                                                                                                                                                                     | Define a `TrajectoryRecord` type that holds per-stage state vectors and costs for one forward scenario. Specify storage as a contiguous buffer indexed by `[scenario][stage]` for cache-friendly backward pass access.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| GAP-031 | Low      | cobre-core                   | [Internal Structures](../data-model/internal-structures.md)                                                                      | 12                  | The `Stage` definition lists fields `num_scenarios` and `sampling_method` that appear to be scenario generation parameters, not stage structural properties. These overlap with the `scenario_source` configuration in `stages.json`. The relationship and deduplication between these fields is unclear.                                                                                                                                             | Clarify that `num_scenarios` maps to `n_openings` from `stages.json` and `sampling_method` is a legacy field replaced by `scenario_source.sampling_scheme`. Remove or deprecate the ambiguous fields.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| GAP-032 | Low      | cobre-sddp                   | [Training Loop](../architecture/training-loop.md)                                                                                | 2.1a                | The event channel uses `Option<broadcast::Sender<TrainingEvent>>` but `broadcast` is not a standard library type. This appears to reference `tokio::sync::broadcast` which implies an async runtime dependency. For a synchronous MPI binary, this is architecturally significant.                                                                                                                                                                    | Clarify the event channel implementation: recommend `crossbeam::channel` or `std::sync::mpsc` for the synchronous CLI binary. Reserve `tokio::sync::broadcast` for the async Python/MCP interfaces (deferred crates).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| GAP-033 | Low      | cobre-comm                   | [Communicator Trait](../hpc/communicator-trait.md)                                                                               | 4.5                 | The `train` function signature shows `C: Communicator + SharedMemoryProvider` as the generic bound, but the solver interface trait shows `C: Communicator` only (without `SharedMemoryProvider`). The exact set of generic bounds on the training entry point is inconsistent between the two specs.                                                                                                                                                  | Unify: the training entry point should require `C: Communicator + SharedMemoryProvider` since shared memory is used for the opening tree and case data. Update the solver interface trait example to match.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| GAP-034 | Low      | cobre-sddp                   | [Cut Management Implementation](../architecture/cut-management-impl.md)                                                          | 1.3                 | The cut pool capacity formula `warm_start_cuts + max_iterations x forward_passes` assumes a fixed `forward_passes_per_iteration` value. If the configuration allows dynamic adjustment of forward pass count, the preallocation would be invalid. The spec should confirm that `forward_passes` is fixed for the entire run.                                                                                                                          | Confirm that `forward_passes` is immutable after initialization. Document this as a precondition of the deterministic slot assignment formula.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| GAP-035 | Low      | all 8 crates                 | [Configuration Reference](../configuration/configuration-reference.md)                                                           | 7                   | The complete example `config.json` includes `"method": "domination"` for cut selection, but the minimal viable solver uses Level-1 (per implementation ordering section 6). The example should reflect the minimal viable defaults to avoid confusion.                                                                                                                                                                                                | Update the example to use `"method": "level1"` and `"risk_measure": "expectation"` to match the minimal viable configuration.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| GAP-036 | High     | cobre-sddp, cobre-solver     | [Solver Workspaces](../architecture/solver-workspaces.md)                                                                        | not in reading list | Solver workspaces define thread-local solver instances with per-stage basis caches, but the exact lifecycle (creation, reuse across iterations, destruction) and the interaction with `rayon`/thread-pool patterns are not fully specified in the trait spec. The workspace is referenced by multiple specs but its own spec was not in the critical reading list.                                                                                    | **Resolved** -- Consolidated workspace lifecycle summary added to [Solver Workspaces](../architecture/solver-workspaces.md) SS1.3a. Documents four lifecycle phases (Creation, Per-iteration reuse, Per-stage transition, Destruction) in a single table. Threading model interaction note documents the fixed-size thread pool invariant. Simulation reuse note confirms workspaces are NOT freed between Training and Simulation phases.                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| GAP-037 | High     | cobre-sddp                   | [Training Loop](../architecture/training-loop.md)                                                                                | 4.3                 | The lower bound computation states "first-stage LP objective value (the deterministic lower bound)" but the LB is described as coming from `allreduce` with `ReduceOp::Min`. If all ranks solve the same stage-1 LP (since stage 1 has a fixed initial state), the LB should be identical across ranks. Using `Min` implies ranks may have different LB values. Clarify whether each rank solves stage 1 once or per-scenario.                        | **Resolved** -- Lower bound extraction mechanism clarified in [Training Loop](../architecture/training-loop.md) SS4.3b. LB is the stage-1 LP objective value from any rank's first stage-1 solve. Aggregation via `allreduce` with `ReduceOp::Min` as a defensive guard against numerical noise. Two-call baseline: one `allreduce Min` for LB, one `allreduce Sum` for UB statistics `[cost_sum, cost_sum_sq, scenario_count]`.                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| GAP-038 | High     | cobre-sddp                   | [Training Loop](../architecture/training-loop.md), [Convergence Monitoring](../architecture/convergence-monitoring.md)           | 4.3, 1              | The upper bound is computed as "mean total forward cost across all trajectories" but the upper bound std computation requires the raw per-scenario costs. After `allreduce Sum`, each rank has only the global sum and sum-of-squares, not individual costs. The std formula uses individual deviations. Either a `gatherv` of all costs or an online variance formula (Welford's algorithm via sum, sum-of-squares, count) must be specified.        | **Resolved** -- Upper bound variance aggregation protocol specified in [Convergence Monitoring](../architecture/convergence-monitoring.md) SS3.1a. Per-rank local computation of three sufficient statistics (`local_count`, `local_sum`, `local_sum_sq`). Allreduce payload `[f64; 3]` with `ReduceOp::Sum`. Global variance formula with Bessel's correction. Numerical stability analysis confirms single-pass formula acceptable at production scale.                                                                                                                                                                                                                                                                                                                                                                                                                        |
| GAP-039 | High     | cobre-stochastic, cobre-sddp | [Scenario Generation](../architecture/scenario-generation.md), [Training Loop](../architecture/training-loop.md)                 | 2.3, 5.2, 4.2       | False gap. The concern described a "rank 0 generates and broadcasts noise" pattern that does not exist in the Cobre architecture. Each MPI rank independently generates forward pass noise via deterministic seed derivation (Scenario Generation SS2.2a). No MPI broadcast of noise data is required.                                                                                                                                                | **Resolved (false gap)** -- The described broadcast pattern does not exist. Each rank derives noise independently via SipHash-1-3 seed `(base_seed, iteration, scenario, stage)` (SS2.2a). A clarifying architectural note was added to SS2.2. Reclassified by scenario-spec-gap-closure plan, ticket-003.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |

## 4. Key Decisions Resolved by Stakeholder Review

The following items are explicitly NOT gaps. They represent intentional design decisions documented in the specification corpus.

**Deferred features are not gaps.** The following are deferred by design and do not block the minimal viable solver:

- Python bindings (cobre-python), TUI (cobre-tui), MCP server (cobre-mcp)
- TCP and shared-memory communication backends
- CVaR risk measure, Cyclic horizon mode, LML1 cut selection
- External and Historical sampling schemes
- CLP solver backend
- Multi-cut formulation, FPHA hyperplanes, GNL dispatch, batteries
- Non-convex simulation extensions (linearized head, unit commitment)
- Complete tree mode (DECOMP-like)
- Monte Carlo backward sampling
- State deduplication in the backward pass

**Architectural hooks for deferred features.** The trait-based architecture (RiskMeasure, CutSelectionStrategy, HorizonMode, SamplingScheme, SolverInterface, Communicator) provides extension points for all deferred features. The enum dispatch pattern (flat enum with match at call sites) is documented in the learnings and does not require breaking changes to add variants. The compile-time monomorphization pattern (SolverInterface, Communicator) similarly accommodates new backends via feature flags. These hooks are adequately specified.

**"Real crates, real boundaries" is a design constraint, not a gap.** The requirement that all 11 crate boundaries are respected (implementation ordering requirement 2) means that crate interface gaps are blockers even when the functionality they serve is deferred. This is why GAP-001 (System type), GAP-004 (StageTemplate construction), GAP-012 (load_case API), and GAP-020 (SimulationWriter) are logged as gaps despite being "obvious" implementation details.

**Stub element types.** Contracts, Pumping Stations, and Non-Controllable sources have code-path stubs in the minimal viable solver. The stubs are specified in implementation ordering section 7 and internal structures sections 7-9. No additional specification is needed for the stubs beyond the existing entity type definitions.

## 5. Known Performance Risks

| Risk                                                              | Source                                                                        | Impact                                                                                                                                                                                                                                         | Mitigation                                                                                                                                                                                                                                                              |
| ----------------------------------------------------------------- | ----------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Dominated cut detection at 7.7G FLOPs                             | [Cut Selection Trait](../architecture/cut-selection-trait.md) SS6.4           | Dominated strategy is $\mathcal{O}(\lvert\text{active cuts}\rvert \times \lvert\text{visited states}\rvert)$ per stage per check. At production scale: 15,000 cuts x 192 states x 2,080 state dims x 120 stages = 7.7 billion FLOPs per check. | Not in minimal viable (Level-1 is selected). Flag for feature-gated implementation with optional parallelization when dominated strategy is added.                                                                                                                      |
| `Result`-returning hot-path methods (`solve`, `solve_with_basis`) | [Solver Interface Trait](../architecture/solver-interface-trait.md) SS2.4     | Every LP solve returns `Result`, adding branch prediction overhead on the hot path. With millions of solves per training run, the error path cost is unknown.                                                                                  | Require error-path benchmarking during initial implementation. Measure the overhead of `Result` unwrapping vs. a panic-on-error alternative. The learnings (epic-04) flag this explicitly.                                                                              |
| LP scaling strategy unresolved                                    | [Solver Abstraction](../architecture/solver-abstraction.md) SS3               | Production-scale LPs with 8,000+ variables and accumulating cuts may exhibit poor numerical conditioning without scaling, leading to solver retries and convergence degradation.                                                               | Adopt single-phase scaling as baseline (GAP-010). Profile with production-scale test cases early.                                                                                                                                                                       |
| Cut pool memory at 28 GB per rank                                 | [Cut Management Implementation](../architecture/cut-management-impl.md) SS1.3 | The pre-allocated cut pool requires ~28 GB per MPI rank at production scale (120 stages x 15,000 cuts x 2,080 state dims x 8 bytes). On nodes with 4 ranks per NUMA domain, this totals 112 GB for cut pools alone.                            | Monitor actual memory usage during integration testing. The shared memory optimization (cut pool via `SharedRegion`) can reduce this to ~28 GB per node if adopted. Level-1 selection reduces the active cut count, but pre-allocation is based on worst-case capacity. |
| Missing baseline latency targets                                  | [Production Scale Reference](../overview/production-scale-reference.md)       | The production scale reference specifies system sizes and memory estimates but provides no wall-clock time targets (e.g., "iteration time < 30s" or "total training < 2 hours"). Without targets, performance regressions cannot be detected.  | Define baseline latency targets after the first end-to-end integration test on production-scale data. Use these as regression gates in CI.                                                                                                                              |

## 6. Summary Statistics

**By severity (5 Blockers resolved: GAP-001, GAP-002, GAP-003, GAP-004, GAP-005; 16 High resolved: GAP-006 through GAP-017, GAP-036, GAP-037, GAP-038, GAP-039; 3 Medium resolved: GAP-020, GAP-023, GAP-029):**

| Severity             | Count  |
| -------------------- | ------ |
| Blocker (unresolved) | 0      |
| Blocker (resolved)   | 5      |
| High (unresolved)    | 0      |
| High (resolved)      | 16     |
| Medium (unresolved)  | 10     |
| Medium (resolved)    | 3      |
| Low                  | 5      |
| **Total**            | **39** |
| **Total unresolved** | **15** |

**By crate (a gap affecting multiple crates is counted once per crate; Blocker column shows unresolved only):**

| Crate            | Blocker | High | Medium | Low | Total |
| ---------------- | ------- | ---- | ------ | --- | ----- |
| cobre-core       | 0       | 1    | 1      | 2   | 4     |
| cobre-io         | 0       | 1    | 3      | 1   | 5     |
| cobre-stochastic | 0       | 1    | 2      | 1   | 4     |
| cobre-solver     | 0       | 4    | 0      | 1   | 5     |
| cobre-sddp       | 0       | 11   | 9      | 3   | 23    |
| cobre-comm       | 0       | 0    | 0      | 2   | 2     |
| cobre-cli        | 0       | 1    | 1      | 1   | 3     |
| ferrompi         | 0       | 1    | 0      | 1   | 2     |

Note: Gap counts per crate exceed the total gap count because some gaps affect multiple crates. cobre-sddp dominates because it is the integration crate that consumes APIs from all other crates; most of its gaps are interface definitions at crate boundaries. Resolved gaps (5 Blockers, 16 High, 3 Medium) are excluded from the severity-level unresolved counts above; the rows remain in the inventory table for historical reference with **Resolved** markers.

## 7. Resolution Log

| GAP ID  | Resolved Date | Plan / Epic                         | Ticket     | Resolution Summary                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| ------- | ------------- | ----------------------------------- | ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| GAP-001 | 2026-02-26    | gap-resolution / epic-02            | ticket-004 | System struct sketch with public API in Internal Structures SS1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| GAP-002 | 2026-02-26    | gap-resolution / epic-02            | ticket-005 | Decommissioned = Non-existing in Internal Structures SS2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| GAP-003 | 2026-02-26    | gap-resolution / epic-02            | ticket-006 | rkyv serialization in Input Loading Pipeline SS6                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| GAP-004 | 2026-02-26    | gap-resolution / epic-03            | ticket-008 | LP memory layout with exact index formulas in Solver Abstraction SS2; StageTemplate construction ownership in Solver Interface Trait SS4.4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| GAP-005 | 2026-02-26    | gap-resolution / epic-03            | ticket-009 | State vector format, patch sequence with index formulas, and StageIndexer struct in Training Loop SS5; row layout arithmetic in Solver Abstraction SS2.2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| GAP-006 | 2026-02-26    | spec-readiness / epic-05            | ticket-011 | State vector MPI wire format: raw `[f64]` reinterpretation, scenario-major indexing, one allgatherv per stage, counts/displs formulas in Training Loop SS5.4a                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| GAP-007 | 2026-02-26    | spec-readiness / epic-05            | ticket-012 | Cut synchronization MPI wire format: `#[repr(C)]` `CutWireRecord` struct with native endianness, 4-byte explicit padding for 8-byte alignment, `allgatherv` over `T = u8` raw bytes, exact per-cut size $24 + n_{state} \times 8$ bytes (16,664 at production scale), no version byte. Specified in [Cut Management Implementation](../architecture/cut-management-impl.md) SS4.2a.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| GAP-008 | 2026-02-26    | spec-readiness / epic-05            | ticket-013 | AR lag fixing constraints promoted from inline remark in LP Formulation SS5 to formal constraint family section SS5a: $N \times L$ equality constraints $a_{h,\ell} = \hat{a}_{h,\ell}$ with dual variable $\pi^{lag}_{h,\ell}$ as cut coefficient for inflow lag state variables. Cross-references to [Solver Abstraction](../architecture/solver-abstraction.md) SS2.2, [Training Loop](../architecture/training-loop.md) SS7.2 and SS4.2a. Specified in [LP Formulation](../math/lp-formulation.md) SS5a.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| GAP-009 | 2026-02-26    | spec-readiness / epic-05            | ticket-014 | Split `patch_rhs_bounds(&mut self, patches: &[(usize, f64)])` into two methods: `patch_row_bounds(&mut self, patches: &[(usize, f64, f64)])` (SS2.3) for row lower/upper bounds and `patch_col_bounds(&mut self, patches: &[(usize, f64, f64)])` (SS2.3a) for column lower/upper bounds. Each patch tuple is (index, new_lower, new_upper). HiGHS and CLP API mappings documented in SS2.3/SS2.3a. `patch_col_bounds` noted as not used in minimal viable SDDP. All references across 5 spec files updated.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| GAP-010 | 2026-02-26    | gap-resolution / epic-04            | ticket-015 | Adopt `SolverAuto` (delegate scaling to solver backend) as the baseline for the minimal viable solver. HiGHS and CLP internal scaling enabled by default. Cobre-managed scaling (`GeometricMean`, `Equilibration`) and two-phase scaling deferred to a later optimization pass. Rationale: mature solver scaling, double-scaling risk, reduced initial complexity. Decision in [Solver Abstraction](../architecture/solver-abstraction.md) SS3; forward reference in [Solver Workspaces](../architecture/solver-workspaces.md) SS2.1; `SolverAuto` workflow clarification in SS2.5.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| GAP-011 | 2026-02-26    | spec-readiness / epic-05            | ticket-016 | Adopt selective cut addition as the baseline for the minimal viable solver. Only active cuts (per activity bitmap) are added via `addRows` at each stage transition; inactive cuts are excluded from the solver LP entirely. Bulk loading with bound deactivation deferred to a later optimization pass. Rationale: smaller LPs (fewer rows, smaller factorization), natural fit for full-rebuild strategy (SS11.2), presolve disabled for warm-start compatibility, O(1) activity bitmap lookup. `CutBatch` assembly cost $O(n_\text{active} \times n_\text{state})$. Decision in [Solver Abstraction](../architecture/solver-abstraction.md) SS5.4.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| GAP-012 | 2026-02-26    | spec-readiness / epic-05            | ticket-017 | `load_case` public API defined in [Input Loading Pipeline](../architecture/input-loading-pipeline.md) SS8.1: function signature `pub fn load_case(path: &Path) -> Result<System, LoadError>`, `LoadError` enum with 5 variants (`IoError`, `ParseError`, `SchemaError`, `CrossReferenceError`, `ConstraintError`), responsibility boundary (complete loading sequence SS2.1--2.6, excludes policy loading SS2.7), owned `System` return type (not `Arc<System>`), no `Config` parameter (config loaded internally per SS2.1). Cross-reference in [Internal Structures](../data-model/internal-structures.md) SS1.7 updated to point to SS8.1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| GAP-013 | 2026-02-26    | spec-readiness / epic-05            | ticket-018 | `TrainingEvent` enum with 11 variants (7 per-iteration + 4 lifecycle) and typed payload structs defined in [Training Loop](../architecture/training-loop.md) SS2.1b. Crate assignment: cobre-core. Helper struct `StoppingRuleResult` for `ConvergenceUpdate.rules_evaluated`. Derives `Clone + Debug` only (no `Send + Sync`). Events carry no per-event timestamps; consumers timestamp on receipt. Cross-references to Convergence Monitoring SS4.1, Structured Output, and Convergence Monitoring SS2.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| GAP-014 | 2026-02-26    | spec-readiness / epic-05            | ticket-019 | SipHash-1-3 via `siphasher` crate 1.x as the deterministic hash function for seed derivation. Little-endian fixed-width input encoding: 20 bytes `(base_seed:u64, iteration:u32, scenario:u32, stage:u32)` for forward pass, 16 bytes `(base_seed:u64, opening_index:u32, stage:u32)` for opening tree. 64-bit hash output seeds `Pcg64` RNG. Non-cryptographic. `DefaultHasher` rejected (output not stable across Rust versions). Native endianness rejected (breaks cross-platform reproducibility). Specified in [Scenario Generation](../architecture/scenario-generation.md) SS2.2a.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| GAP-015 | 2026-02-26    | spec-readiness / epic-05            | ticket-020 | Simulation-based stopping rule integration specified in [Convergence Monitoring](../architecture/convergence-monitoring.md) SS2.3a. Synchronous (blocking) execution within Training Loop SS2.1 step 5. Reuses training solver workspaces (no separate LP instances). Fresh InSample draws from fixed opening tree with separate seed derived via `base_seed + iteration` and SipHash-1-3 (Scenario Generation SS2.2a). `replications` scenarios distributed across ranks using contiguous block assignment (Training Loop SS4.3). All OpenMP threads participate. First check stores baseline costs without triggering convergence. Performance: ~840 LP solves per rank, ~1.7s at production scale (T=120, 100 replications, 16 ranks).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| GAP-016 | 2026-02-26    | spec-readiness / epic-05            | ticket-021 | Phase-Training Loop alignment table added to [CLI and Lifecycle](../architecture/cli-and-lifecycle.md) SS5.2a. All 7 phases mapped to authoritative spec sections with ordering constraints and cross-reference links. Audit confirmed existing phase ordering is consistent with Training Loop assumptions: MPI init first in Startup, rank-0 `load_case` in Validation precedes rkyv broadcast in Initialization, solver workspace allocation and stage template construction complete before Training, PAR preprocessing and opening tree generation in Scenario Gen precede Training. No inconsistencies found; no corrections needed.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| GAP-017 | 2026-02-26    | spec-readiness / epic-05            | ticket-022 | Standalone ferrompi API reference in [Backend: Ferrompi](../hpc/backend-ferrompi.md) SS7, updated to match the real ferrompi 0.1 crate. Documents `Mpi` struct (`init`, `init_thread`, `world`, `thread_level`, `wtime`, `version`, `is_initialized`, `is_finalized`, Drop), `Communicator` (rank, size, allgatherv, allreduce, broadcast, barrier, split_shared, allreduce_init + summary tables for 60+ additional methods), `SharedWindow<T>` (`allocate`, `local_slice`, `local_slice_mut`, `remote_slice`, `fence`, `lock`/`lock_all`, `raw_handle`, `comm_size`, Drop), supporting types (`ThreadLevel` with `#[repr(i32)]`, `ReduceOp` with `Prod` variant, `MpiDatatype` sealed trait with `DatatypeTag`, `Error` thiserror enum with 5 variants, `MpiErrorClass` with 24+ variants including `Raw(i32)`, `SplitType`, `Request`, `PersistentRequest`, `Status`, `Info`, `LockType`, `LockGuard`, `LockAllGuard`). SS1-SS5 wrapper code updated: `ferrompi::Op` to `ferrompi::ReduceOp`, `bcast` to `broadcast`, `split_shared` (renamed), `SharedWindow::new` to `SharedWindow::allocate`, `as_slice(count)` to `remote_slice(0)`, `as_mut_slice` to `local_slice_mut`, `ferrompi::MpiError` to `ferrompi::Error` enum, `map_mpi_error` rewritten as `map_ferrompi_error`. |
| GAP-036 | 2026-02-26    | gap-resolution / epic-04            | ticket-023 | Consolidated workspace lifecycle summary added to [Solver Workspaces](../architecture/solver-workspaces.md) SS1.3a. Documents four lifecycle phases (Creation, Per-iteration reuse, Per-stage transition, Destruction) in a single table with frequency and relevant section cross-references. Destruction phase specifies C API destructors (`Highs_destroy()`, `Clp_deleteModel()`) and sequential main-thread execution. Threading model interaction note documents the fixed-size thread pool invariant and `rayon::current_thread_index()` correctness requirement. Simulation reuse note confirms workspaces are NOT freed between Training and Simulation phases. Cross-references to Hybrid Parallelism SS1, Training Loop SS4.3, CLI and Lifecycle SS5.2.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| GAP-037 | 2026-02-26    | gap-resolution / epic-04            | ticket-024 | Lower bound extraction mechanism clarified in [Training Loop](../architecture/training-loop.md) SS4.3b. LB is the stage-1 LP objective value from any rank's first stage-1 solve -- a single `f64`, not a per-scenario statistic. Aggregation via `allreduce` with `ReduceOp::Min` as a defensive guard against numerical noise (all ranks compute the same value in exact arithmetic; `Min` preserves the $LB \leq z^*$ invariant). Two-call baseline: one `allreduce Min` for LB, one `allreduce Sum` for UB statistics `[cost_sum, cost_sum_sq, scenario_count]`. Custom 4-element fused reduction noted as optimization. Single-rank mode: no communication needed. SS4.3 LB bullet updated to cross-reference SS4.3b.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| GAP-038 | 2026-02-26    | gap-resolution / epic-04            | ticket-025 | Upper bound variance aggregation protocol specified in [Convergence Monitoring](../architecture/convergence-monitoring.md) SS3.1a. Per-rank local computation of three sufficient statistics (`local_count`, `local_sum`, `local_sum_sq`). Allreduce payload `[f64; 3]` in order `[sum, sum_sq, count]` with `ReduceOp::Sum`. Global variance formula with Bessel's correction: $s^2 = (Q - N \cdot \bar{c}^2) / (N - 1)$. SS3.1 variance formula updated from population variance ($N$ denominator) to sample variance ($N - 1$). Numerical stability analysis: single-pass formula acceptable for typical SDDP ($\varepsilon_{\text{rel}} \lesssim 10^{-12}$ at production scale); two-pass deferred as optimization. Edge case: $N = 1$ sets $\sigma = 0$ with warning. Cross-references to Training Loop SS4.3b, Convergence Monitoring SS1, SS2.4.                                                                                                                                                                                                                                                                                                                                                                                                                             |
| GAP-029 | 2026-02-26    | gap-resolution / epic-04            | ticket-020 | Exhaustive 26-rule cross-reference validation checklist added to [Input Loading Pipeline](../architecture/input-loading-pipeline.md) SS2.6. Covers all `_id` foreign-key fields across 7 entity types, structural checks (cascade DAG acyclicity, self-loop/self-pump prevention), coverage checks (initial conditions, inflow model, FPHA hyperplanes), and policy graph stage references. Each rule specifies source entity, reference field, target entity, validation rule, and `LoadError` variant. Execution order and error collection strategy documented.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| GAP-023 | 2026-02-26    | gap-resolution / epic-04            | ticket-021 | `OpeningTree` Rust struct with flat `Box<[f64]>` storage and per-stage variable branching defined in [Scenario Generation](../architecture/scenario-generation.md) SS2.3a. Per-stage branching factor `openings_per_stage: Box<[usize]>` sourced from `StageSamplingConfig.num_scenarios`; cumulative `stage_offsets` for O(1) offset-based access. Accessor method `fn opening(&self, stage: usize, opening_idx: usize) -> &[f64]`. `fn n_openings(&self, stage: usize) -> usize` returns per-stage count. `OpeningTreeView<'a>` borrow type decouples cobre-stochastic (owns generation) from cobre-sddp (borrows during training). Forward/backward separation clarified: `OpeningTree` is the backward pass structure; forward pass uses it only via `InSample` scheme. Uniform branching is the common degenerate case. Premature ownership analysis (Arc vs SharedRegion) removed  deferred to implementation. **Updated 2026-02-26**: revised from uniform `n_openings` to per-stage `openings_per_stage` to support variable branching and complete tree mode DECOMP.                                                                                                                                                                                                      |
| GAP-020 | 2026-02-26    | gap-resolution / epic-04            | ticket-029 | Output writer API defined in [Output Infrastructure](../data-model/output-infrastructure.md) SS6. Nine API elements: `SimulationParquetWriter` with `new`, `write_scenario`, `finalize` (SS6.2); `TrainingParquetWriter` with `new`, `write_iteration`, `write_rank_timing`, `finalize` (SS6.3); `OutputError` enum with 4 variants `IoError`, `SerializationError`, `SchemaError`, `ManifestError` (SS6.4); manifest/metadata/dictionary standalone functions (SS6.5); `write_policy_checkpoint` for FlatBuffers (SS6.6); anchoring `write_results` function (SS6.1). Parquet library: `arrow-rs`. Mirrors the `load_case`/`LoadError` pattern from Input Loading Pipeline SS8.1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| GAP-039 | 2026-02-27    | scenario-spec-gap-closure / epic-02 | ticket-003 | False gap. The described "rank 0 broadcasts noise" pattern does not exist in the architecture. Each MPI rank independently generates noise via deterministic seed derivation (SS2.2a in scenario-generation.md). No new spec content required beyond a clarifying note in SS2.2.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |

## 8. Cross-References

| Target                                                                                                      | Relevance                                                                                                                                                                                             |
| ----------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [Implementation Ordering](./implementation-ordering.md)                                                     | Defines the 8 minimal viable crates, phase structure, and trait variant selection that scope this inventory                                                                                           |
| [Cross-Reference Index](../cross-reference-index.md)                                                        | Per-crate reading lists (section 2) used to systematically identify which specs to audit for each crate                                                                                               |
| [Training Loop](../architecture/training-loop.md)                                                           | Most-connected spec; coordinates forward/backward passes across cobre-sddp, cobre-solver, cobre-stochastic, cobre-comm. Source of 11 gaps (GAP-005, 006, 008, 013, 018, 026, 030, 032, 037, 038, 039) |
| [Solver Abstraction](../architecture/solver-abstraction.md)                                                 | Defines the LP layout convention and solver contract. Contains 0 open points (GAP-010, GAP-011 resolved) and the cut pool design (GAP-034)                                                            |
| [Solver Interface Trait](../architecture/solver-interface-trait.md)                                         | Formal solver trait definition. Source of GAP-009 (resolved: `patch_rhs_bounds` split into `patch_row_bounds`/`patch_col_bounds`) and performance risk (Result on hot path)                           |
| [Internal Structures](../data-model/internal-structures.md)                                                 | Defines the in-memory data model consumed by all downstream crates. Source of GAP-001, 002, 012, 031                                                                                                  |
| [Input Loading Pipeline](../architecture/input-loading-pipeline.md)                                         | Defines the cobre-io to cobre-core handoff. Source of GAP-003, 012, 029                                                                                                                               |
| [Scenario Generation](../architecture/scenario-generation.md)                                               | Defines the cobre-stochastic pipeline. Source of GAP-014, 022, 023, 039                                                                                                                               |
| [Cut Management Implementation](../architecture/cut-management-impl.md)                                     | Defines the FCF runtime structure. Source of GAP-007, 024, 034                                                                                                                                        |
| [Production Scale Reference](./production-scale-reference.md)                                               | Provides system dimensions and memory estimates used to assess performance risks                                                                                                                      |
| [Configuration Reference](../configuration/configuration-reference.md)                                      | Documents all config parameters. Source of GAP-019, 027, 035                                                                                                                                          |
| [Communicator Trait](../hpc/communicator-trait.md)                                                          | Defines the cobre-comm API surface. Source of GAP-033                                                                                                                                                 |
| [Backend: Ferrompi](../hpc/backend-ferrompi.md)                                                             | Defines the MPI backend. Source of GAP-017                                                                                                                                                            |
| [Convergence Monitoring](../architecture/convergence-monitoring.md)                                         | Defines stopping rule evaluation. Source of GAP-015, 038                                                                                                                                              |
| Accumulated Learnings (Epic 04)  `plans/spec-readiness/learnings/epic-04-summary.md` (outside mdBook tree) | Known issues from prior spec readiness work: dominated strategy FLOP cost, Result-returning hot-path methods, convention blockquote verification                                                      |
