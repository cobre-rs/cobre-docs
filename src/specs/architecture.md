# Architecture

This section contains the architectural specifications that define how Cobre's SDDP solver is structured at the software level. Where the [Mathematical Formulations](./math.md) section defines _what_ the solver computes and the [Data Model](./data-model.md) section defines _what_ data flows in and out, the architecture specs define _how_ the solver is organized internally: the training loop that drives SDDP iteration, the simulation engine that evaluates trained policies, the solver abstraction layer that isolates LP solver dependencies, the scenario generation pipeline that produces correlated noise vectors, the input loading sequence that builds the in-memory model, the validation pipeline that rejects malformed inputs before any computation begins, the CLI entrypoint that orchestrates the full execution lifecycle, the convergence monitor that decides when to stop, the cut management implementation that maintains the future cost function, and the extension points that allow algorithm variants to be composed at configuration time.

Together, these 13 specs fully describe the runtime architecture of the Cobre solver. They are written at the behavioral level -- specifying component responsibilities, interaction contracts, data flow, and parallelization strategy -- without prescribing Rust module boundaries or struct layouts. A developer implementing a component should be able to read its architecture spec alongside the referenced math and data-model specs and produce a correct implementation without ambiguity. Where performance-critical design decisions exist (e.g., thread-trajectory affinity in the forward pass, streaming output in simulation, LP template cloning for solver workspaces), each spec documents the rationale and the constraints that drove the choice.

The specs assume familiarity with the SDDP algorithm as described in [SDDP Algorithm](./math/sddp-algorithm.md), the stage LP structure from [LP Formulation](./math/lp-formulation.md), and the input/output contracts from the [Data Model](./data-model.md) section. Readers new to the solver's high-level design should start with [CLI and Lifecycle](./architecture/cli-and-lifecycle.md), which maps the full execution sequence from process invocation to shutdown, before diving into the individual subsystem specs.

## Reading Order

The specs have extensive cross-references, so reading order matters. The following sequence builds concepts from the outermost orchestration layer inward to the solver core:

1. **[Training Loop](./architecture/training-loop.md)** -- Start here. Defines the SDDP iteration lifecycle (forward pass, backward pass, convergence check), the four abstraction points (risk measure, cut formulation, horizon mode, sampling scheme), state management, and dual extraction for cut coefficients. This is the central spec that most other architecture specs plug into.
2. **[Simulation Architecture](./architecture/simulation-architecture.md)** -- How trained policies are evaluated on large scenario sets: parallel distribution, per-scenario forward pass, policy compatibility validation, non-convex extensions, statistics computation, and streaming output.
3. **[Solver Abstraction](./architecture/solver-abstraction.md)** -- The unified interface through which the SDDP algorithm interacts with LP solvers: solver interface contract, LP layout convention, cut pool design, error categories, retry logic, dual normalization, basis storage, and compile-time solver selection.
4. **[Solver HiGHS Implementation](./architecture/solver-highs-impl.md)** -- HiGHS-specific patterns for the C API, batch bound operations, retry strategy, basis management, memory footprint, and SDDP-tuned configuration.
5. **[Solver CLP Implementation](./architecture/solver-clp-impl.md)** -- CLP-specific patterns for the C API baseline, mutable pointer optimization, C++ wrapper strategy for LP template cloning, retry strategy, basis management, and memory footprint.
6. **[Solver Workspaces](./architecture/solver-workspaces.md)** -- Thread-local solver workspace infrastructure and LP scaling: NUMA-local solver instances, pre-allocated buffers, and the bridge between the solver abstraction and the HPC execution layer.
7. **[Scenario Generation](./architecture/scenario-generation.md)** -- The scenario generation pipeline: PAR model preprocessing, correlated noise generation, the sampling scheme abstraction, external scenario integration, load scenario generation, and the memory layout optimized for the forward pass hot-path.
8. **[Input Loading Pipeline](./architecture/input-loading-pipeline.md)** -- Rank-0 centric loading pattern, file loading sequence with dependency ordering, sparse time-series expansion, data broadcasting, parallel policy loading for warm-start, and transition to the in-memory data model.
9. **[Extension Points](./architecture/extension-points.md)** -- How algorithm variants are selected, composed, and validated at configuration time: the four abstraction points mapped to their configuration sources, validation rules, and cross-variant compatibility constraints.
10. **[CLI and Lifecycle](./architecture/cli-and-lifecycle.md)** -- Program entrypoint, command-line interface, exit codes, execution phase lifecycle, conditional execution modes, configuration resolution hierarchy, and job scheduler integration.
11. **[Validation Architecture](./architecture/validation-architecture.md)** -- Multi-layer input validation pipeline: the five validation layers, error collection strategy, error type catalog, and validation report format.
12. **[Convergence Monitoring](./architecture/convergence-monitoring.md)** -- Convergence criteria, stopping rules, bound computation with cross-rank aggregation, and training log format for progress reporting.
13. **[Cut Management Implementation](./architecture/cut-management-impl.md)** -- How the mathematical cut management concepts are implemented: future cost function runtime structure, cut selection on the pre-allocated cut pool, FlatBuffers serialization for checkpoint/resume, cross-rank cut synchronization via MPI, cut coefficient extraction via fixing constraint duals, and cut activity tracking.

## Spec Index

| Spec                                                                   | Description                                                                                              | Math/Data Reference                                                                                                                  |
| ---------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| [Training Loop](./architecture/training-loop.md)                       | SDDP iteration lifecycle, abstraction points, forward/backward passes, state management, dual extraction | [SDDP Algorithm](./math/sddp-algorithm.md), [Cut Management](./math/cut-management.md), [Stopping Rules](./math/stopping-rules.md)   |
| [Simulation Architecture](./architecture/simulation-architecture.md)   | Policy evaluation on large scenario sets, parallel distribution, statistics, streaming output            | [Risk Measures](./math/risk-measures.md), [Discount Rate](./math/discount-rate.md), [Output Schemas](./data-model/output-schemas.md) |
| [Solver Abstraction](./architecture/solver-abstraction.md)             | Unified LP solver interface, LP layout, cut pool design, error handling, basis storage                   | [LP Formulation](./math/lp-formulation.md)                                                                                           |
| [Solver HiGHS Implementation](./architecture/solver-highs-impl.md)     | HiGHS C API integration, batch operations, SDDP-tuned configuration                                      | [LP Formulation](./math/lp-formulation.md)                                                                                           |
| [Solver CLP Implementation](./architecture/solver-clp-impl.md)         | CLP C/C++ API integration, LP template cloning, mutable pointer optimization                             | [LP Formulation](./math/lp-formulation.md)                                                                                           |
| [Solver Workspaces](./architecture/solver-workspaces.md)               | Thread-local NUMA-aware solver instances, pre-allocated buffers, LP scaling                              | [LP Formulation](./math/lp-formulation.md)                                                                                           |
| [Scenario Generation](./architecture/scenario-generation.md)           | PAR preprocessing, correlated noise, sampling schemes, external scenarios, memory layout                 | [PAR Inflow Model](./math/par-inflow-model.md), [Input Scenarios](./data-model/input-scenarios.md)                                   |
| [Input Loading Pipeline](./architecture/input-loading-pipeline.md)     | Rank-0 loading, dependency ordering, sparse expansion, broadcast, warm-start policy loading              | [Input Directory Structure](./data-model/input-directory-structure.md), [Binary Formats](./data-model/binary-formats.md)             |
| [Extension Points](./architecture/extension-points.md)                 | Algorithm variant selection, composition, validation, cross-variant compatibility                        | [Risk Measures](./math/risk-measures.md), [Infinite Horizon](./math/infinite-horizon.md)                                             |
| [CLI and Lifecycle](./architecture/cli-and-lifecycle.md)               | Program entrypoint, CLI, exit codes, phase lifecycle, configuration resolution                           | [Input Directory Structure](./data-model/input-directory-structure.md)                                                               |
| [Validation Architecture](./architecture/validation-architecture.md)   | Five validation layers, error collection, error catalog, validation report                               | [Input System Entities](./data-model/input-system-entities.md), [Input Constraints](./data-model/input-constraints.md)               |
| [Convergence Monitoring](./architecture/convergence-monitoring.md)     | Convergence criteria, bound computation, cross-rank aggregation, training log                            | [Stopping Rules](./math/stopping-rules.md), [Upper Bound Evaluation](./math/upper-bound-evaluation.md)                               |
| [Cut Management Implementation](./architecture/cut-management-impl.md) | FCF runtime structure, cut selection, FlatBuffers serialization, MPI cut sync, activity tracking         | [Cut Management](./math/cut-management.md), [Binary Formats](./data-model/binary-formats.md)                                         |

## Conventions

All specs in this section describe behavioral contracts rather than implementation artifacts. Component responsibilities are stated as "the component does X" rather than "the struct has field Y". This keeps the specs stable across refactors while remaining precise enough to verify an implementation against. Where a spec references mathematical quantities (cut coefficients, dual variables, risk weights), it uses the notation from [Notation Conventions](./overview/notation-conventions.md) and links to the relevant math spec for the full derivation. Where a spec references data schemas (Parquet columns, JSON keys, FlatBuffers tables), it links to the relevant data-model spec for the normative definition. Cross-references to the [High-Performance Computing](./hpc.md) section appear where parallelization strategy is architecturally significant (MPI distribution, OpenMP threading, NUMA placement).
